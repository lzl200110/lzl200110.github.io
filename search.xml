<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>observer观察者模式</title>
      <link href="/2023/12/15/observer%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/12/15/observer%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式似乎是一个经常被使用的设计模式，其核心思想是:当我要观察变化的对象时，不需要进行轮询，只需要在对象那里进行注册，当对象变化时，其自动提醒我发生了变化(执行我注册的回调)。</p><p>典型的代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">field_changed</span><span class="params">(T&amp; source, <span class="type">const</span> std::string&amp; field_name)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">(T&amp; source, <span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; obs : observers) &#123;</span><br><span class="line">obs-&gt;<span class="built_in">field_changed</span>(source, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">subscribe</span><span class="params">(Observer&lt;T&gt;* f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), f);</span><br><span class="line"><span class="keyword">if</span> (it == observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">observers.<span class="built_in">push_back</span>(f);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">unsubscribe</span><span class="params">(Observer&lt;T&gt;* f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">erase_if</span>(observers,</span><br><span class="line">                     [&amp;](Observer&lt;T&gt;* item) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> item == f; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;Observer&lt;T&gt;*&gt; observers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们要观察的是<code>Perosn</code>类的<code>age</code>属性,实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> : <span class="keyword">public</span> Observable&lt;Person&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">const</span> <span class="type">int</span> age)</span></span>;</span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsolePersonObserver</span> : <span class="keyword">public</span> Observer&lt;Person&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">field_changed</span><span class="params">(Person&amp; source, <span class="type">const</span> std::string&amp; field_name)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    : <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::set_age</span><span class="params">(<span class="type">const</span> <span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;age==age)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="built_in">notify</span>(*<span class="keyword">this</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Person::get_age</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsolePersonObserver::field_changed</span><span class="params">(Person&amp; source, <span class="type">const</span> std::string&amp; field_name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (field_name == <span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Person&#x27;s age have change to &quot;</span> &lt;&lt; source.<span class="built_in">get_age</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>Perosn</code>通过<code>set_age</code>修改年龄时，我们注册的<code>ConsolePersonObserver</code>会执行<code>field_changed</code>来处理。</p><p>观察者模式比较固定，下面给出需要注意的几个要点。</p><h3 id="记录observers的容器"><a href="#记录observers的容器" class="headerlink" title="记录observers的容器"></a>记录observers的容器</h3><p>上面代码在<code>Observable</code>接口在中使用<code>vector</code>来记录注册的观察者,导致我们在<code>unsubscribe</code>时需要通过遍历来查找。</p><p>选择存储观察者的容器时需要考虑以下几点：</p><ul><li>是否允许重复订阅</li><li>notify需不需要按订阅顺序</li><li>观察者是否有不同的优先级</li></ul><p>几个可能的方案：vector、set、list+index。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>上述代码没有考虑多线程的问题，如果同时<code>unsubscribe</code>和<code>subscribe</code>被调用，vector很有可能出现意想不到的结果。<br>加锁的实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">(T&amp; source, <span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"><span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; obs : observers) &#123;</span><br><span class="line">obs-&gt;<span class="built_in">field_changed</span>(source, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">subscribe</span><span class="params">(Observer&lt;T&gt;* f)</span> </span>&#123;</span><br><span class="line"><span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), f);</span><br><span class="line"><span class="keyword">if</span> (it == observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">observers.<span class="built_in">push_back</span>(f);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">unsubscribe</span><span class="params">(Observer&lt;T&gt;* f)</span> </span>&#123;</span><br><span class="line"><span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">erase_if</span>(observers,</span><br><span class="line">                     [&amp;](Observer&lt;T&gt;* item) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> item == f; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;Observer&lt;T&gt;*&gt; observers;</span><br><span class="line">std::mutex mtx&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一个方案就是使用线程安全的vector(如tbb中的concurrent_vector),这样可以避免我们手动管理锁，但无法保证顺序(一个一个添加的两个对象不能保证按顺序得到通知)。</p><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>上文提到的加锁方案解决了多线程的问题，但是可能导致死锁，假设<code>field_changed</code>函数中可能会调用<code>unsubscribe</code>,调用链如下：<br><code> notify() ----&gt; field_changed() ----&gt; unsubscribe()</code><br>由于<code>notify</code>时进行了<code>lock</code>操作，<code>unsubscribe</code>会尝试获取一个已经获得的锁。这就是<em>可重入</em>的问题。</p><ul><li><p>可以放弃从集合删除元素，仅仅把其设为nullptr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">unsubscribe</span><span class="params">(Observer&lt;T&gt;* f)</span> </span>&#123;</span><br><span class="line"><span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(observers.<span class="built_in">begin</span>(),observers.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(it!=observers.<span class="built_in">end</span>())&#123;</span><br><span class="line">*it=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以在notify时copy一份observers</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">(T&amp; source, <span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">std::vector&lt;Observer&lt;T&gt;*&gt; observers_cpoy;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">observers_cpoy = observers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; obs : observers_cpoy) &#123;</span><br><span class="line">obs-&gt;<span class="built_in">field_changed</span>(source, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以禁止重入，不提供可重入的接口。</p></li></ul><p>对于可重入的观察者，将<code>mutex</code>替换为<code>recursivee_mutex</code>往往是可以的，能够一定程度上避免死锁的产生。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>观察者模式是被广泛使用的设计模式，在实现时，需要考虑以下几个方面：</p><ul><li>希望为观察者传递什么信息?</li><li>如何处理取消订阅的接口?</li><li>观察者会被多线程调用吗,需要可重入吗?</li><li>允许观察者多次注册吗?</li></ul>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 观察者模式 </tag>
            
            <tag> observer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buildera构建者模式</title>
      <link href="/2023/12/14/buildera%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/12/14/buildera%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SOLID设计原则</title>
      <link href="/2023/12/14/SOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2023/12/14/SOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="SOLID设计原则"><a href="#SOLID设计原则" class="headerlink" title="SOLID设计原则"></a>SOLID设计原则</h1><p>SOLID 是面向对象设计五大重要原则的首字母缩写，当我们设计类和模块时，遵守 SOLID 原则就如同它的名字一样：(solid，可靠的)，可以让软件更加稳定、灵活和健壮。</p><h2 id="Single-Responsibility-Principle（SRP）：单一职责原则"><a href="#Single-Responsibility-Principle（SRP）：单一职责原则" class="headerlink" title="Single Responsibility Principle（SRP）：单一职责原则"></a>Single Responsibility Principle（SRP）：单一职责原则</h2><p>每个类只有一个责任，只有一个改变的理由。让一个类或者一个模块专注于单一的功能，减少功能之间的耦合程度。这样做在需要修改某个功能时，就不会影响到其他的功能。 </p><p>案例:日记Journal<br>希望实现一个日记，其中包含标题和多个条目</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Journal</span>&#123;</span><br><span class="line">    string title;</span><br><span class="line">    vector&lt;string&gt; entries;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Journal</span><span class="params">(<span class="type">const</span> string&amp; title)</span> : title&#123;</span>title&#125; &#123;&#125;</span><br><span class="line">    <span class="comment">// 添加条目</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Journal::add</span><span class="params">(<span class="type">const</span> string&amp; entry)</span></span>&#123;</span><br><span class="line">       <span class="type">static</span> <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">       entries.<span class="built_in">push_back</span>(boost::<span class="built_in">lexical_cast</span>&lt;string&gt;(count++)</span><br><span class="line">            + <span class="string">&quot;: &quot;</span> + entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在希望添加将日记持久化到文件的功能，一个简单的实现方式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Journal::save</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s:entries)&#123;</span><br><span class="line">        ofs&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现将持久化功能交给日志，然而日志的责任是<em>保存日志条目</em>，而不是把它们写道磁盘上。如果将持久化的功能添加到 Journal 中，后续对持久化的方法进行修改(写到云端等)，每个受影响的类中需要进行<em>大量的微小的更改</em>。<br>较为正确的实现方式为，单独创建一个类实现持久化功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersistenceManager</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">save</span><span class="params">(<span class="type">const</span> Journal&amp; j,<span class="type">const</span> string &amp; filename)</span></span>&#123;</span><br><span class="line">        <span class="function">ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s:j.entries)&#123;</span><br><span class="line">            ofs&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以：单一职责原则的含义为：<strong>每个类只有一个责任，只有一个改变的理由，相同的职责放到一起，不同的职责分解到不同的接口和实现中去</strong>。</p><h2 id="Open-Closed-Principle（OCP）：开闭原则"><a href="#Open-Closed-Principle（OCP）：开闭原则" class="headerlink" title="Open Closed Principle（OCP）：开闭原则"></a>Open Closed Principle（OCP）：开闭原则</h2><p>开闭原则含义是 <strong>类应该是对扩展开放，对修改关闭的</strong>，一个类独立之后就不应该去修改它，而是以扩展的方式适应新需求。<br>案例 数据过滤：</p><p>在数据库中，拥有一个范围的产品，每个产品具有颜色和尺寸。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum class Color&#123;</span><br><span class="line">    Red,</span><br><span class="line">    Blue,</span><br><span class="line">    Green</span><br><span class="line">&#125;;</span><br><span class="line">enum class Size&#123;</span><br><span class="line">    Small,</span><br><span class="line">    Middle,</span><br><span class="line">    Large</span><br><span class="line">&#125;;</span><br><span class="line">struct Product&#123;</span><br><span class="line">    string name;</span><br><span class="line">    Color color;</span><br><span class="line">    Size size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，希望给产品添加按照颜色过滤功能。可能制作如下的过滤器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct ProductFilter &#123;</span><br><span class="line">    using Items  = vector&lt;Product*&gt;;</span><br><span class="line">&#125;</span><br><span class="line">ProductFilter::Items ProductFilter::by_color(Item items,Color color)&#123;</span><br><span class="line">    Items result;</span><br><span class="line">    for(auto &amp; i:items)&#123;</span><br><span class="line">        if(i-&gt;color==color)&#123;</span><br><span class="line">            result.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过段时间后，需要按照尺寸进行过滤，可能添加以下功能，然后<em>重新编译文件</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ProductFilter::Items ProductFilter::by_size(Item items,Size size)&#123;</span><br><span class="line">    Items result;</span><br><span class="line">    for(auto &amp; i:items)&#123;</span><br><span class="line">        if(i-&gt;size==size)&#123;</span><br><span class="line">            result.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在添加按照尺寸和颜色过滤功能，继续添加代码？<br>在该场景中，<strong>开闭原则</strong>或许是有用的，该原则声明<em><strong>类型是对扩展开放，对修改关闭的</strong></em>。<br>具体而言，我们希望过滤是可扩展的(可能在其他的编译单元中)，而不必修改现有的代码(可能以及发布)。<br>将过滤器分为两个部分：<em>筛选器</em> 和 <em>规范</em>：对规范接口做一个简单的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; </span><br><span class="line">struct Specification&#123;</span><br><span class="line">   virtual bool is_satisfied(T* item) = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>T是一个模板类型，在上例中为Product。<br>然后，需要一个基于Specification的过滤方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct Filter&#123;</span><br><span class="line">    virtual vector&lt;T*&gt; filter(vector&lt;T*&gt; items,Specification&lt;T&gt; &amp;spec) = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>filter 函数接受所有项目和一个规范，并返回符合规范的所有项目。基于前述，改进的过滤器的实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BetterFilter</span> : Filter&lt;Product&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">vector&lt;Product*&gt; <span class="title">filter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;Product*&gt; items,</span></span></span><br><span class="line"><span class="params"><span class="function">        Specification&lt;Product&gt;&amp; spec)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;Product*&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : items)</span><br><span class="line">            <span class="keyword">if</span> (spec.<span class="built_in">is_satisfied</span>(p))</span><br><span class="line">                result.<span class="built_in">push_back</span>(p);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的Specification的实现为：相当与一个function函数对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ColorSpecification</span> : Specification&lt;Product&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Color color;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ColorSpecification</span><span class="params">(<span class="type">const</span> Color color)</span> :</span></span><br><span class="line"><span class="function">    color&#123;</span>color&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_satisfied</span><span class="params">(Product* item)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item-&gt;color == color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>开闭原则：<strong>你不需要返回你已经编写和测试过的代码，并对其进行更改</strong>。也就对应对修改关闭、对扩展开放。<br>上述实例中：我们制定了 Specification 和 Filter，从那时起，我们所要做的就是实现任何一个接口（不需要修改接口本身，也不需要修改Product类）来实现新的过滤机制,同时也可e结合<strong>组合模式</strong> 来实现组合过滤。</p><h2 id="Liskov-Substitution-Principle（LSP）：里氏替换原则"><a href="#Liskov-Substitution-Principle（LSP）：里氏替换原则" class="headerlink" title="Liskov Substitution Principle（LSP）：里氏替换原则"></a>Liskov Substitution Principle（LSP）：里氏替换原则</h2><p>里氏替换原则定义为：如果一个接口可以接受类型为 Parent 的对象，那么它应该同样地可以接受类型为 Child 的对象，而不会有任何破坏<br>里氏替换原则的核心是：对<em>父类有效的方法对子类同样有效</em></p><h2 id="Interface-Segregation-Principle（ISP）：接口隔离原则"><a href="#Interface-Segregation-Principle（ISP）：接口隔离原则" class="headerlink" title="Interface Segregation Principle（ISP）：接口隔离原则"></a>Interface Segregation Principle（ISP）：接口隔离原则</h2><p>接口隔离原则定义为： <strong>将复杂接口的部分分隔成单独的接口，以避免迫使实现者实现他们并不真正需要的功能</strong><br>案例：Contianer<br>你实现了容器一个接口，同时支持list、vector、tree的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Contianer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//list 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">get</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">put</span><span class="params">(T&amp;)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(Position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//vector 操作</span></span><br><span class="line">    <span class="keyword">virtual</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span>) =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//tree 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">balance</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当你实现该接口时，不得不实现3个相关的概念(可能你只需要vector相关的方法)，却不得不实现全部的方法。</p><h2 id="Dependence-Inversion-Principle（DIP）：依赖反转原则"><a href="#Dependence-Inversion-Principle（DIP）：依赖反转原则" class="headerlink" title="Dependence Inversion Principle（DIP）：依赖反转原则"></a>Dependence Inversion Principle（DIP）：依赖反转原则</h2><p>高级模块不应该依赖低级模块，而是依赖抽象接口，抽象接口不应该依赖细节，细节应该依赖抽象接口。<br>案例：日志类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ILogger</span>&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ILogger</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">int</span> level,<span class="type">const</span> string &amp;s)</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConsoleLogger</span> : ILogger&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">int</span> level,<span class="type">const</span> string &amp;s)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">set_log_color</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Log :&quot;</span>&lt;&lt;s&lt;&lt;std::endl;</span><br><span class="line">        <span class="built_in">close_log_color</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>依赖Log 模块的上层不应该依赖ConsoleLogger，应该靠ILogger*，在构造时传入相应的依赖。</p>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> SOLID </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>visitor 访问者模式</title>
      <link href="/2023/12/14/visitor%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/12/14/visitor%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>对于具有层次类型的对象类型(有继承关系)，为结构中所有类型添加方法需要大幅度的修改代码，若进行提前规划，使用访问者模式可避免修改大量代码。</p><p>假设在解析数学表达式，该数学表达式又double类型的值和运算符组成。如：<br><code>(1.0+(2.0+3.0))</code><br>该表达式可以表示为如下的层次结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Express</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Express</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleExpress</span> : <span class="keyword">public</span> Express &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DoubleExpress</span><span class="params">(<span class="type">double</span> v)</span></span></span><br><span class="line"><span class="function">    : value(v) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> value&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddtionExpress</span> : <span class="keyword">public</span> Express &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AddtionExpress</span>(Express* l, Express* r)</span><br><span class="line">    : <span class="built_in">left</span>(l)</span><br><span class="line">    , <span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">~<span class="built_in">AddtionExpress</span>() <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="keyword">delete</span> left;</span><br><span class="line"><span class="keyword">delete</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Express *left, *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种层次结构下，若需要向<strong>Express的继承者</strong>添加一些方法，如，<code>打印表达式</code>、<code>对表达式进行求值</code>，该如何实现？</p><h2 id="侵入式访问者"><a href="#侵入式访问者" class="headerlink" title="侵入式访问者"></a>侵入式访问者</h2><p>上述问题中，不同的类有不同实现，使用多态可以很好得而达到要求，侵入式的访问者通过向所有类中添加一个多态方法来实现新功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Express</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Express</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(std::ostringstream&amp; oss)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleExpress</span> : <span class="keyword">public</span> Express &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DoubleExpress</span><span class="params">(<span class="type">const</span> <span class="type">double</span> v)</span></span></span><br><span class="line"><span class="function">    : value(v) &#123;</span>&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::ostringstream&amp; oss)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">oss &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> value&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddtionExpress</span> : <span class="keyword">public</span> Express &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AddtionExpress</span>(Expression* <span class="type">const</span> left, Expression* <span class="type">const</span> right)</span><br><span class="line">    : <span class="built_in">left</span>(l)</span><br><span class="line">    , <span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::ostringstream&amp; oss)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">left-&gt;<span class="built_in">print</span>(oss);</span><br><span class="line">oss &lt;&lt; <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">right-&gt;<span class="built_in">print</span>(oss);</span><br><span class="line">        oss &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">AddtionExpress</span>() <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="keyword">delete</span> left;</span><br><span class="line"><span class="keyword">delete</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Express *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Express* e = <span class="keyword">new</span> AddtionExpress&#123;</span><br><span class="line">    <span class="keyword">new</span> DoubleExpress&#123;<span class="number">1.0f</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> AddtionExpress&#123;<span class="keyword">new</span> DoubleExpress&#123;<span class="number">2.0f</span>&#125;, <span class="keyword">new</span> DoubleExpress&#123;<span class="number">3.0f</span>&#125;&#125;&#125;;</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    e-&gt;<span class="built_in">print</span>(oss);</span><br><span class="line">    std::cout&lt;&lt;oss.<span class="built_in">str</span>()&lt;&lt;std::endl;<span class="comment">//print (1+(2+3))</span></span><br><span class="line">    <span class="keyword">delete</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码似乎很好的完成了需求，似乎还很好的用到了面向对象的方法：多态。<br>但是却有这明显弊端：</p><ul><li>如果层次结构中中多个类(20个)，需要添加一个新的方法时(求值)，我们不得不再次修改<strong>全部</strong>的代码(bad),这是一个复杂的工程。</li></ul><p>正真的原因在于<strong>单一职责原则</strong>，<code>打印</code>功能h是一个单独的职责，与其让所有表达式提供print接口，不如引入一个负责打印功能的类ExpressPrinter。然后，还可以引入一个ExpressaEvaluator,它负责求值的功能。</p><h2 id="反射式访问者"><a href="#反射式访问者" class="headerlink" title="反射式访问者"></a>反射式访问者</h2><p>引入ExpressPrinter后，代码结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Expression</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleExpress</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DoubleExpress</span><span class="params">(<span class="type">const</span> <span class="type">double</span> v)</span></span></span><br><span class="line"><span class="function">    : value(v) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdditionExpress</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span>;</span><br><span class="line"><span class="built_in">AdditionExpress</span>(Expression* <span class="type">const</span> left, Expression* <span class="type">const</span> right)</span><br><span class="line">    : <span class="built_in">left</span>(left)</span><br><span class="line">    , <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">~<span class="built_in">AdditionExpress</span>() <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="keyword">delete</span> left;</span><br><span class="line"><span class="keyword">delete</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Expression *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Expression* e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> de = <span class="built_in">dynamic_cast</span>&lt;DoubleExpress*&gt;(e)) &#123;</span><br><span class="line">oss &lt;&lt; de-&gt;value;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span> ae = <span class="built_in">dynamic_cast</span>&lt;AdditionExpress*&gt;(e)) &#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(ae-&gt;left);</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(ae-&gt;right);</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::ostringstream oss&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> e = <span class="keyword">new</span> AdditionExpress&#123;</span><br><span class="line">    <span class="keyword">new</span> DoubleExpress&#123;<span class="number">1</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> AdditionExpress&#123;<span class="keyword">new</span> DoubleExpress&#123;<span class="number">2</span>&#125;, <span class="keyword">new</span> DoubleExpress&#123;<span class="number">3</span>&#125;&#125;&#125;;</span><br><span class="line">ExpressionPrinter ep;</span><br><span class="line">ep.<span class="built_in">print</span>(e);</span><br><span class="line">std::cout &lt;&lt; ep.<span class="built_in">str</span>() &lt;&lt; std::endl; <span class="comment">//print (1+(2+3))</span></span><br><span class="line">    <span class="keyword">delete</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过引入ExpressionPrinter实现打印功能，我们不需要大幅度修改已有代码，只需要注意访问权限，将ExpressionPrinter说明为Express的有缘即可。<br>在看ExpressionPrinter，其print函数接受一个<strong>基类指针</strong>，但我们需要根据指针实际类型来执行不同的方法。于是，<strong>反射</strong>在这里就h登场，通过<strong>dynamic_cast</strong>来判断基类指针是否为某一类型，通过<strong>穷举全部子类</strong>即可得到指针的实际类型，然后根据不同类型调用不同的打印方法。<br>上述代码也存在明显缺点:</p><ul><li>在进行<code>dynamic_cast</code>反射时，我们要保证：1、全部子类被包含，不能有遗漏；2、先检查子类，在检查父类。<br>若先判断了父类，那么<code>dynamic_cast</code>将子类指针转为父类指针是会成功的，这大概率会引起一个错误。</li></ul><h2 id="二重分发"><a href="#二重分发" class="headerlink" title="二重分发"></a>二重分发</h2><p>回顾<code>反射式访问者</code>，可以发现相较于<code>侵入式访问者</code>，由于其缺少了<strong>多态</strong>,导致我们不得不根据反射来判断类型，若有多态的vtable,我们可以交由多态来判断类型执行相应的函数。<br>为此，这里引入<strong>二重分发</strong>的概念，它是经典访问者的关键。</p><p>“分发”是确定要调用哪个函数的问题—-具体来说指需要多少信息才能调用正确的函数。<br>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stuff</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> : Stuff&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> : Stuff&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Foo* foo)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Bar* bar)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果创建一个普通的Foo对象，那么其调用func()是没有任何问题的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo* f = <span class="keyword">new</span> Foo&#123;&#125;;</span><br><span class="line"><span class="built_in">func</span>(f);</span><br></pre></td></tr></table></figure><p>但是，如果决定将其转换为基类指针，编译器将不知道调用哪个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stuff* f = <span class="keyword">new</span> Foo&#123;&#125;;</span><br><span class="line"><span class="built_in">func</span>(f);  <span class="comment">//oops! 调用func(Foo*)还是func(Bar*)呢？</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从多态角度考虑以下，有没有不进行RTTI(dynamic_cast)检查的情况下，使系统调用正确的重载函数？答案显然是有的。<br>可以看到，当通过<code>Stuff</code>调用某个函数时，若这个函数是多态的，可以直接分发的正确的组件，而组件又可以调用正确的函数重。这就被称为<strong>二重分发</strong>，因为：</p><ul><li>首先，我们在实际的对象上进行了一次多态调用。</li><li>在多态调用的内部，由调用了函数重载。(在对象内部，this指针拥有正确的类型，因此可以调用正确的函数重载)。<br>二重分发代码如下:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stuff</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> : Stuff&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> : Stuff&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Foo* foo)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Bar* bar)</span></span>&#123;&#125;</span><br><span class="line">Stuff* s = <span class="keyword">new</span> Foo&#123;&#125;;</span><br><span class="line">s-&gt;<span class="built_in">call</span>();<span class="comment">//正确调用 func(Foo*);</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="经典访问者"><a href="#经典访问者" class="headerlink" title="经典访问者"></a>经典访问者</h2><p>访问者的经典实现就是使用<strong>二重分发</strong>。命名有如下规则：</p><ul><li>访问者成员函数通常命名为visit();</li><li>被访问者实现的成员函数通常称为accept();<br>现在，让我们实现基于<strong>二重分发</strong>的经典访问者,由于ExpressVisitor 和Expression相互引用，我们无法将其放到一个头文件中，需要将部分实现放到.cpp文件中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// visitor.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressVisitor</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(ExpressVisitor* visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Expression</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleExpress</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DoubleExpress</span><span class="params">(<span class="type">const</span> <span class="type">double</span> v)</span></span></span><br><span class="line"><span class="function">    : value(v) &#123;</span>&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(ExpressVisitor* visitor)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="type">double</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdditionExpress</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">AdditionExpress</span>(Expression* <span class="type">const</span> left, Expression* <span class="type">const</span> right)</span><br><span class="line">    : <span class="built_in">left</span>(left)</span><br><span class="line">    , <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">~<span class="built_in">AdditionExpress</span>() <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="keyword">delete</span> left;</span><br><span class="line"><span class="keyword">delete</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(ExpressVisitor* visitor)</span> <span class="keyword">override</span></span>;</span><br><span class="line">Expression *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 两重分发</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressVisitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(DoubleExpress* de)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(AdditionExpress* ae)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span> : ExpressVisitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(DoubleExpress* de)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">oss &lt;&lt; de-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(AdditionExpress* ae)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">ae-&gt;left-&gt;<span class="built_in">accept</span>(<span class="keyword">this</span>);</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">ae-&gt;right-&gt;<span class="built_in">accept</span>(<span class="keyword">this</span>);</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::ostringstream oss&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//visitor.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;visitor.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoubleExpress::accept</span><span class="params">(ExpressVisitor* visitor)</span> </span>&#123;</span><br><span class="line">visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdditionExpress::accept</span><span class="params">(ExpressVisitor* visitor)</span> </span>&#123;</span><br><span class="line">visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//visitor_test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;visitor.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> e = <span class="keyword">new</span> AdditionExpress&#123;</span><br><span class="line">    <span class="keyword">new</span> DoubleExpress&#123;<span class="number">1</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> AdditionExpress&#123;<span class="keyword">new</span> DoubleExpress&#123;<span class="number">1</span>&#125;, <span class="keyword">new</span> DoubleExpress&#123;<span class="number">1</span>&#125;&#125;&#125;;</span><br><span class="line">ExpressionPrinter ep&#123;&#125;;</span><br><span class="line">ep.<span class="built_in">visit</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>基于上述代码，如果我们要实现求值的访问者也非常简单,只需要注意修改访问权限的友元类即可：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// visitor.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressionEvaluator</span> : ExpressVisitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(DoubleExpress* de)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">res = de-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(AdditionExpress* ae)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">ae-&gt;left-&gt;<span class="built_in">accept</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">auto</span> temp = res;</span><br><span class="line">ae-&gt;right-&gt;<span class="built_in">accept</span>(<span class="keyword">this</span>);</span><br><span class="line">res += temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// visitor_test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;visitor.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> e = <span class="keyword">new</span> AdditionExpress&#123;</span><br><span class="line">    <span class="keyword">new</span> DoubleExpress&#123;<span class="number">1</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> AdditionExpress&#123;<span class="keyword">new</span> DoubleExpress&#123;<span class="number">2</span>&#125;, <span class="keyword">new</span> DoubleExpress&#123;<span class="number">3</span>&#125;&#125;&#125;;</span><br><span class="line">ExpressionPrinter ep&#123;&#125;;</span><br><span class="line">ep.<span class="built_in">visit</span>(e);</span><br><span class="line">ExpressionEvaluator ev&#123;&#125;;</span><br><span class="line">ev.<span class="built_in">visit</span>(e);</span><br><span class="line">std::cout &lt;&lt; ep.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ev.<span class="built_in">result</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="std-visit"><a href="#std-visit" class="headerlink" title="std::visit"></a>std::visit</h2><p>C++ 标准库提供了变化体(variant)来强化union,也提供了<code>std::visit</code>，来访问variant，这里简要说明std::visit怎么使用，结合cppref <a href="https://zh.cppreference.com/w/cpp/utility/variant/visit">https://zh.cppreference.com/w/cpp/utility/variant/visit</a> 中示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">struct</span> <span class="title class_">overloaded</span> : Ts... &#123;</span><br><span class="line"><span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Ts&gt; <span class="built_in">overloaded</span>(Ts...) -&gt; overloaded&lt;Ts...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VarHelper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> arg)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> arg)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::string&amp; arg)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var&#123;<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">std::<span class="built_in">visit</span>(<span class="comment">//1</span></span><br><span class="line">    [](<span class="keyword">auto</span>&amp;&amp; arg) &#123;</span><br><span class="line">    <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为 &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot; 的 int\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">double</span>&gt;)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为 &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot; 的 double\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为 &quot;</span> &lt;&lt; std::<span class="built_in">quoted</span>(arg) &lt;&lt; <span class="string">&quot; 的 std::string\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="literal">false</span>, <span class="string">&quot;观览器无法穷尽类型！&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    var);</span><br><span class="line">std::<span class="built_in">visit</span>(VarHelper&#123;&#125;, var);   <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">visit</span>(<span class="comment">//3</span></span><br><span class="line">    overloaded&#123;[](<span class="keyword">auto</span> arg) &#123; std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;,</span><br><span class="line">               [](<span class="type">double</span> arg) &#123; std::cout &lt;&lt; std::fixed &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;,</span><br><span class="line">               [](<span class="type">const</span> std::string&amp; arg) &#123; std::cout &lt;&lt; std::<span class="built_in">quoted</span>(arg) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;&#125;,</span><br><span class="line">    var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码定义了变化体var,并提供了3种visit的方法，第一种使用RTTI在运行时判断类别，是<strong>反射式方法</strong>。第二、三种都是<strong>经典方法</strong>，其中2传入了一个重载了operator()()的结构体对象，可以根据不同的arg类型进行不同的调用，3与2类似，<br>其中overloaded 结构体继承了3个lambda对象(lambda对象重载了operator()())函数，因此这里传入的overloaded对象与2中VarHelper{}相似，都是提供了int、double、string的重载operator()()的结构体而已。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>访问者模式允许我们为层次结构的每个元素添加一些功能和行为，我们已经知道了如下方法：</p><ul><li><strong>侵入式方法</strong>：为结构中每个对象添加一个虚函数，可行但违背了开闭原则。</li><li><strong>反射式方法</strong>：定义一个单独n访问者，使用<em>dynamic_cast</em>进行运行时转发。</li><li><strong>经典方法</strong>：二重分发，结构中每个元素通过accept()函数来接受访问者，通过访问者的细分(多态)，强化结构的功能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 访问者模式 </tag>
            
            <tag> visitor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析C++中的inline关键字</title>
      <link href="/2023/12/13/inline/"/>
      <url>/2023/12/13/inline/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>inline</strong>关键字一直被认为去声明<strong>内联函数</strong>(优先采用函数的内联替换而非进行函数调用)，然而关键词 inline 的含义是非强制的，编译器拥有对任何未标记为inline的函数使用内联替换的自由，和对任何标记为 inline 的函数生成函数调用的自由。<br>换句话说函数是否内联，与是否被inlineo标识无关，而由编译器(优化参数)决定。</p><h2 id="ODR-one-define-rule-单一定义原则"><a href="#ODR-one-define-rule-单一定义原则" class="headerlink" title="ODR(one define rule) 单一定义原则"></a>ODR(one define rule) 单一定义原则</h2><p>ORD的要求如下：</p><ul><li>任何变量、函数、类类型、枚举类型、概念或模板，在每个<strong>翻译单元</strong>中都只允许有一个定义（其中部分可以有多个声明，但只允许有一个定义）。</li><li>在整个<strong>程序</strong>中，被ODR使用的<strong>非 inline 函数或变量</strong>只允许有且仅有一个定义。</li></ul><p>简要翻译一下这两句话：</p><ul><li><strong>翻译单元指的是每个cpp文件</strong>，显然，若一个函数在某个cpp文件中定义了两次，编译期间编译器一定会报重定义错误。</li><li>若编译器编译通过，代码后续会到<strong>链接阶段</strong>，若main.cpp 调用了一个外部函数foo(int),那么链接器会到其他翻译单元中找 _Z3fooi 函数来进行e链接，若发现a.cpp、b.cpp中都定义了满足条件的foo函数，若链接器无法判断用哪一个，也会报出重定义错误。</li></ul><h2 id="定义与声明的区别"><a href="#定义与声明的区别" class="headerlink" title="定义与声明的区别"></a>定义与声明的区别</h2><p>一个声明是指（通常）将一个名称导入或重导入你的程序的C++构建。一个声明也许是一个定义，取决于导入的实体与其导入的方式，下面给出声明和定义的判断条件。</p><ul><li>Namespace和namespace aliases：namespace的声明与其aliases（别名）总是定义，尽管“定义”这个术语在此环境中不太合适，因为namespace列表的成员在之后会被“扩展”（不同于classes和enumerations）。</li><li>Classes、Class templates、函数、函数templates、成员函数与成员函数templates：当且仅当声明中包含一个与其名称相关的花括号体时，声明就是定义。该规则还适用于unions、operator、成员operator、static成员函数、构造函数与析构函数、以及此类参数版本的explicit特化。</li><li>Enumerations：当且仅当声明中包含用括号括起来的一列枚举。<br>-Local变量与nonstatic数据成员：这些实体常被当做定义处理，尽管这些差别无伤大雅。请注意在函数定义中声明函数的参数的行为本身就是定义行为，因为它指示了local变量，但在函数声明中的非定义的函数参数并不是整个函数的定义。</li><li>Global变量：若一个声明未紧接跟随在extern关键字后或有一个初始化设定式，该Global变量的声明也是其定义。其他情况则不是定义。</li><li>static数据成员：当且仅当声明出现在其所属的类、类模板的外部，或该类或类模板声明了inline或constexpr，它就是定义。</li><li>explicit与Local特化：声明后跟随一个<code>template&lt;&gt;</code>或<code>template&lt;...&gt;</code>时本身就是定义，除了static数据成员的explicit特化，static数据成员模板在其含一个initializer时也是一个定义。其他的声明不是定义。那些包含类型别名（typedef 或 using），使用声明、</li></ul><h2 id="inline-命名空间"><a href="#inline-命名空间" class="headerlink" title="inline 命名空间"></a>inline 命名空间</h2><p>内联命名空间能够把<strong>空间内函数和类型导出到父命名空间中</strong>,这样即使不指定子命名空间也可以使用其空间内的函数和类型了。<br>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Parent &#123;</span><br><span class="line">    <span class="keyword">namespace</span> Child1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Child1::foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">namespace</span> Child2</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Child2::foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parent::Child1::<span class="built_in">foo</span>();<span class="comment">//Child1::foo()</span></span><br><span class="line">    Parent::<span class="built_in">foo</span>();<span class="comment">//Child2::foo()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过inline Child2 命名空间，将Child2::foo()导出到其父命名空间中，使得我们可以使用Parent::foo() 来访问Parent::Child2::foo()中的内容，简化了代码。</p><h2 id="inline-函数、inline-变量"><a href="#inline-函数、inline-变量" class="headerlink" title="inline 函数、inline 变量"></a>inline 函数、inline 变量</h2><p>前面ODR规则说明了定义在整个程序中只能出现一次, <code>但对于inline函数或inline变量来说，在 ODR 使用了它的每个翻译单元中都需要一个定义</code>。<br>换句话说，inline的函数和变量可以`违背`规则2, 当链接器查找函数时，发现函数是inline的就不考虑它，这样就不会出现重定义的错误。</p><p>举一个例子，你实现了一个head only的日志功能，其代码可能如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LogPrintf(level, fmt, ...) \</span></span><br><span class="line"><span class="meta">LogPrintfFunc(LOG_MODULE_ID, level, std::source_location::current(), fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="comment">//！ 通过宏来打印日志</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogFatal(fmt, ...)  LogPrintf(LOG_LEVEL_FATAL, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogErr(fmt, ...)    LogPrintf(LOG_LEVEL_ERROR, fmt, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//！ 将要打印的内容封装为 LogContent ，然后dispatch，dispatch调用函数将LogContent打印出来</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogPrintfFunc</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* module_id, <span class="type">int</span> level, <span class="type">const</span> std::source_location location, <span class="type">const</span> <span class="type">char</span>* fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Args... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (level &lt; <span class="number">0</span>) &#123;</span><br><span class="line">level = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (level &gt; LOG_LEVEL_TRACE) &#123;</span><br><span class="line">level = LOG_LEVEL_TRACE;</span><br><span class="line">&#125;</span><br><span class="line">std::string module_id_print = (module_id != <span class="literal">nullptr</span>) ? module_id : <span class="string">&quot;???&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::chrono::zoned_time now&#123;std::chrono::<span class="built_in">current_zone</span>(), std::chrono::high_resolution_clock::<span class="built_in">now</span>()&#125;;</span><br><span class="line">std::string text&#123;&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fmt != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">text = std::<span class="built_in">vformat</span>(fmt, std::<span class="built_in">make_format_args</span>(args...));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="built_in">catch</span> (std::format_error&amp; e) &#123;</span><br><span class="line"><span class="built_in">LogPrintfFunc</span>(module_id, LOG_LEVEL_WARN, location, <span class="string">&quot;[format parse error]&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LogContent content = &#123;.thread_id = std::this_thread::<span class="built_in">get_id</span>(),</span><br><span class="line">                      .timestamp = std::format(<span class="string">&quot;&#123;&#125;&quot;</span>, now),</span><br><span class="line">                      .module_id = std::<span class="built_in">move</span>(module_id_print),</span><br><span class="line">                      .location = location,</span><br><span class="line">                      .level = level,</span><br><span class="line">                      .text = std::<span class="built_in">move</span>(text)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch</span>(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了控制是否打印的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//！ 开启日志</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogOutput_Enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">id = <span class="built_in">log_add_print_func</span>(log_output_filterfunc, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//！ 关闭</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogOutput_Disable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">log_remove_print_func</span>(id);</span><br><span class="line">id = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码见<a href="../asset/log.hpp">log.hpp</a></p><p>当你使用单个main文件对log进行测试时，发现其运行正常，但到涉及到多个文件依赖log时，就出现了错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;headA.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;headB.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">LogOutput_Enable</span>();</span><br><span class="line">        .....</span><br><span class="line">    <span class="built_in">LogOutput_Disable</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数依赖了A、B两个文件，A、B两个文件在其CPP中依赖了log,当链接器查找 LogOutput_Enable 时，发现A.o,B.o,main.o都提供了一个该副本，链接器无法判断要链接哪一个，只能报重定义的错误。</p><p>而解决方案有两个</p><ul><li>把那些重定义的函数声明为inline，这样A.o中的 LogOutput_Enable 对 main.o 不可见，链接器只会发现一个定义。</li><li>将log.hpp中的声明与定义分离，定义放到log.cpp中，这样只有log.o中包含LogOutput_Enable的定义</li></ul><h2 id="inline-static-成员变量"><a href="#inline-static-成员变量" class="headerlink" title="inline static 成员变量"></a>inline static 成员变量</h2><p>inline 还有一个作用就是用来初始化<strong>类中的static变量</strong><br>在C++17 之前，类静态成员变量只能采用类外定义的方式，如 class B，这样容易出现<strong>忘记定义</strong>或者被<strong>包含到多个文件重定义</strong>的问题。<br>C++17 之后，将类静态成员变量声明了inline 的形式，可以在声明时定义，更加简介也减少了错误的可能性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> std::string text;          <span class="comment">//只是声明</span></span><br><span class="line">&#125;;</span><br><span class="line">std::string B::text&#123;<span class="string">&quot;hello&quot;</span>&#125;;         <span class="comment">//这里才定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> std::string text&#123;<span class="string">&quot;hello&quot;</span>&#125;; <span class="comment">// 声明+定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X::text += <span class="string">&quot; world&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; X::text &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现代C++中 inline 早已不是内联优化的意思，其真正的含义是:“inline说明符可以应用于变量以及函数。声明为inline的变量与函数具有相同的语义:它们一方面可以在多个翻译单元中定义,另一方面又必须在每个使用它们的翻译单元中定义,并且程序的行为就像是同一个变量。”</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> inline </tag>
            
            <tag> ODR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux wayland 腾讯会议 无法共享屏幕解决方案</title>
      <link href="/2023/12/13/wayland%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE/"/>
      <url>/2023/12/13/wayland%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>linux上腾讯会议不支持wayland 协议导致屏幕共享时无法捕获屏幕。<br>使用<code>wemeet-x11</code>启动腾讯会议，开启效果如下<br><img src="/../img/wayland%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE1.png" alt="Alt text"><br>可以看到桌面1和桌面2均显示全黑，说明无法捕获。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用obs采集屏幕创建虚拟摄像头，腾讯会议通过虚拟摄像头来共享屏幕。<br>参见：<a href="https://wiki.archlinuxcn.org/wiki/%E5%B1%8F%E5%B9%95%E6%8D%95%E8%8E%B7">https://wiki.archlinuxcn.org/wiki/屏幕捕获</a></p><ol><li>安装 <strong>obs-studio</strong>、<strong>v4l2loopback-dkms</strong>依赖包<br><code>paru -S obs-studio v4l2loopback-dkms</code></li><li>创建虚拟摄像头</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe v4l2loopback devices=1 video_nr=10 card_label=&#x27;OBS Cam&#x27; exclusive_caps=1</span><br><span class="line">sudo modprobe snd-aloop index=10 id=&#x27;OBS Mic&#x27;</span><br></pre></td></tr></table></figure><p>3.开启obs, source选择要分享的屏幕, 启动虚拟摄像头<br><img src="/../img/wayland%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE2.png" alt="Alt text"></p><p>4.开启腾讯会议，通过开启虚拟摄像头实现屏幕共享，效果如下：</p><p><img src="/../img/wayland%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE3.png" alt="Alt text"></p><p>Tip:如果出现屏幕镜像，在腾讯会议-&gt;设置-&gt;虚拟背景中关闭视频镜像。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> wemeebin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> wayland </tag>
            
            <tag> wemeebin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hyprland QQ 关闭后无法打开GUI窗口解决方案</title>
      <link href="/2023/12/13/HyprlandQQ/"/>
      <url>/2023/12/13/HyprlandQQ/</url>
      
        <content type="html"><![CDATA[<p>Hyprland 关闭窗口一般绑定到快捷键(如：Win +K )，调用 exec killactive 来关闭窗口，关闭窗口不等于关闭程序，这样会导致部分程序的GUI窗口关闭后无法再次打开(该程序还在运行，如QQ等)。</p><p>可以通过 <strong>dispatch killactive</strong> 事件来对部分无法正常工作的程序来特化，killactive 修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! ~/.config/hypr/scripts/killactive.sh</span></span><br><span class="line">file_path=<span class="string">&quot;<span class="variable">$HOME</span>/.config/QQ/qq_window_id&quot;</span></span><br><span class="line"><span class="built_in">echo</span> $(hyprctl activewindow -j | jq -r <span class="string">&quot;.class&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(hyprctl activewindow -j | jq -r <span class="string">&quot;.class&quot;</span>)</span>&quot;</span> = <span class="string">&quot;QQ&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    wid=`xdotool getactivewindow`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$wid</span> &gt; <span class="variable">$file_path</span> </span><br><span class="line">    xdotool windowunmap <span class="variable">$wid</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    hyprctl dispatch killactive <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这段代码作用是：若关闭的窗口为QQ,记录窗口 id ，使用 <code>xdotool windowunmap</code> 来<code>unmap</code>窗口，不关闭窗口。</p><p>恢复QQ窗口对应为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! ~/.config/hypr/scripts/resumeQQ.sh</span></span><br><span class="line">file_path=<span class="string">&quot;<span class="variable">$HOME</span>/.config/QQ/qq_window_id&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$file_path</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    w_id=$(<span class="built_in">cat</span> <span class="string">&quot;<span class="variable">$file_path</span>&quot;</span>)</span><br><span class="line">    xdotool windowmap <span class="variable">$w_id</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    bash linuxqq   </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>检查<strong>window_id</strong> 是否存在，存在就<code>xdotool windowmap</code> 窗口，不存在就启动QQ程序</p><p>以上解决方法需要在启动Hyprland时删除 <strong>qq_window_id</strong> 文件，向<strong>hyprland.conf</strong> 中添加该行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec-once = rm -f ~/.config/QQ/qq_window_id</span><br></pre></td></tr></table></figure><p>配置设置快捷键如下(根据个人喜好配置)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$mainMod = SUPER</span><br><span class="line">bind = $mainMod, Z, exec, bash ~/.config/hypr/scripts/resumeQQ.sh               # QQ</span><br><span class="line">bind = $mainMod+SHIFT, Z, exec, killall -SIGUSR1 /opt/QQ/qq                     # close QQ</span><br><span class="line">bind = $mainMod, K, exec, bash ~/.config/hypr/scripts/killactive.sh             # kill windows</span><br></pre></td></tr></table></figure><p>即可实现<code>Win +K</code> 关闭窗口，<code>Win + Z</code> 打开QQ，<code>Win + Shift +Z</code> 退出QQ</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> linuxqq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hyprland </tag>
            
            <tag> linuxqq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux Kokomi(珊瑚宫心海)光标主题</title>
      <link href="/2023/12/13/Kokomi%E5%85%89%E6%A0%87%E4%B8%BB%E9%A2%98/"/>
      <url>/2023/12/13/Kokomi%E5%85%89%E6%A0%87%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="cursor-therme-Kokomi"><a href="#cursor-therme-Kokomi" class="headerlink" title="cursor_therme (Kokomi)"></a>cursor_therme (Kokomi)</h1><p>珊瑚宫心海主题，适用于linux系统<br>cursors_32、cursors_48、cursor_128分别对应<code>32*32</code>、<code>48*48</code>和<code>128*128</code>大小的鼠标指针</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li><code>git clone https://github.com/lzl200110/Kokomi-cursor.git</code></li><li>将Kokomi文件放到 &#x2F;usr&#x2F;share&#x2F;icons&#x2F;</li><li>选择合适大小文件命名为cursors</li><li>设置光标主题为kokomi<br>  参见 <a href="https://wiki.archlinuxcn.org/wiki/%E5%85%89%E6%A0%87%E4%B8%BB%E9%A2%98">https://wiki.archlinuxcn.org/wiki/光标主题</a></li></ul><h2 id="指针预览"><a href="#指针预览" class="headerlink" title="指针预览"></a>指针预览</h2><p><img src="/../img/image_kokomi.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> 光标主题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 光标主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
