<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-01T08:19:44.662Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yuinhai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++中的SIMD支持</title>
    <link href="http://example.com/2023/12/31/SIMD/"/>
    <id>http://example.com/2023/12/31/SIMD/</id>
    <published>2023-12-31T03:11:55.000Z</published>
    <updated>2024-01-01T08:19:44.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>SIMD 的全称是 Single Instruction Multiple Data，中文名“单指令多数据”。<code>一个SIMD变量可以存储**W&lt;sub&gt;T&lt;/sub&gt;** 个变量</code>，<code>一次SIMD指令可以操作多个数据同时进行计算</code>(W<sub>T</sub>取决于数据的类型T的大小和SIMD指令集类型)。<br><img src="/lzl200110.github.io/../img/simd_intro.png" alt="simd"><br>本文将简单介绍X86上的SIMD内嵌原语，并介绍C++标准库提供的simd泛型，之后结合实例讲解SIMD的使用。</p><h2 id="SIMD内嵌原语"><a href="#SIMD内嵌原语" class="headerlink" title="SIMD内嵌原语"></a>SIMD内嵌原语</h2><p>x86系统提供了128位的<strong>SSE</strong>、256位的<strong>AVX2</strong>、512位的<strong>AVX512</strong>指令集，分别对应XMM、YMM、ZMM寄存器，linux系统可以通过<strong>lscpu</strong>指令查看支持的指令集。<br>x86SIMD的内嵌原语扩展了C语言的数据类型，定义为：<code>__m&lt;位数&gt;&lt;类型&gt;</code>，并提供了操作<code>\_&lt;mm/mm256/mm512&gt;\_&lt;操作类型&gt;_&lt;数据类型&gt;</code>,如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__m128 m1 = _mm_set_ps(<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span>); <span class="comment">// 4个float</span></span><br><span class="line">__m128 m2 = _mm_add_ps(m1, m1);                 <span class="comment">// m1进行向量相加得到m2</span></span><br><span class="line"><span class="type">int</span> *p1 = (<span class="type">int</span> *)<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>), std::<span class="built_in">align_val_t</span>(<span class="number">256</span>));</span><br><span class="line">__m256i m3 = _mm256_load_epi32(p1);             <span class="comment">// 读取p1地址中的8个int到m3</span></span><br><span class="line"><span class="keyword">delete</span>[] p1;</span><br></pre></td></tr></table></figure><p>C语言扩展的SIMD内嵌原语提供了大量操作SIMD的函数，具体可参见<a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">Intel手册</a>。</p><p><em>注: 使用avx2指令时需要添加编译参数-mavx2,使用avx512指令时需要添加编译参数-mavx512f。SSE函数在头文件&lt;nmmintrin.h&gt;中，AVX函数在头文件&lt;immintrin.h&gt;中</em></p><h2 id="STL中的SIMD"><a href="#STL中的SIMD" class="headerlink" title="STL中的SIMD"></a>STL中的SIMD</h2><p>C++在SIMD的基础上提供了支持泛型的SIMD类simd,将复杂的SIMD函数变为简单的操作符重载等，标准库提供的SIMD在<code>&lt;experimental/simd&gt;</code>下。</p><h3 id="SIMD-类型"><a href="#SIMD-类型" class="headerlink" title="SIMD 类型"></a>SIMD 类型</h3><p><img src="/lzl200110.github.io/../img/basic_simd.png" alt="basic_simd"><br>标准库提供了<strong>simd</strong> <strong>、native_simd</strong> 和 <strong>fixed_size_simd</strong> 3种SIMD类型(后两个是simd在Abi上的特化)，<code>simd&lt;T&gt;</code> 和 <code>native_simd&lt;T&gt;</code> 类型的宽度在编译时由实现决定，相反，<code>fixed_size_simd&lt;T, N&gt;</code> 类型的宽度是由开发者决定的一个特定的固定的值。<code>simd</code>使用的是128位的xmm寄存器，<code>native_simd</code>则是根据编译参数<code>-mavx2、-mavx512f</code>等来决定寄存器宽度。</p><p>simd类型提供了size方法来返回其包含的元素个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;experimental/simd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> stdx = std::experimental;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stdx::simd&lt;<span class="type">float</span>&gt;                s1&#123;&#125;;</span><br><span class="line">    stdx::native_simd&lt;<span class="type">float</span>&gt;         s2&#123;&#125;;</span><br><span class="line">    stdx::fixed_size_simd&lt;<span class="type">float</span>, <span class="number">6</span>&gt;  s3&#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s2.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s3.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>g++ main.cpp -o main &amp;&amp; ./main</code>编译并运行，结果为<code>4 4 6</code>,说明 simd 和 native_simd 都使用SSE指令集。</p><p>添加编译参数-mavx2 ，<code>g++ main.cpp -o main -maxv2 &amp;&amp; ./main</code>，结果为<code>4 8 6</code>,此时native_simd使用AVX2指令集。</p><ul><li><strong>simd<T></strong> 提供了与T相同的操作函数(+&#x3D;,&#x3D;&#x3D;,&lt;&lt; 等一系列操作)</li><li><strong>simd<T></strong> 对类型T的要求为<strong>算术类型</strong>(int,float等基本类型)，除了bool和long double 类型</li><li><strong>simd_mask<T></strong> 提供了bool的SIMD,表现为<em>掩码</em>，宽度为simd::size。</li><li><strong>Abi</strong>决定simd的宽度，如<code>simd&lt;int,16&gt;</code> 可以使用一个zmm寄存器或者两个ymm寄存器或者4个xmm寄存器。</li></ul><p><em>注:simd<T>的表现与T相同，区别在与多个数据可以一起计算。由于SIMD提供了一系列的算术操作符重载，因此需要约定T为算术类型。simd_mask提供了SIMD的掩码，可以在选择SIMD数据时发挥作用，对于超出寄存器返回的SIMD如fixed_size_simd&lt;int,64&gt;,Abi可以通过存储到2个zmm的方法实现，这样外部就不需要关注simd布局上的实现。通过stdx::simd,可以避免记录SIMD提供的内嵌原语函数，而是n简答调用函数重载，同时更便于写出平台无关的simdh程序。</em></p><h3 id="SIMD-函数"><a href="#SIMD-函数" class="headerlink" title="SIMD 函数"></a>SIMD 函数</h3><p>上文提到了标准库提供的simd类型，本届介绍在simd类型上的方法。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>不考虑特殊函数(默认、移动、拷贝构造)，simd 提供了如下构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> U &gt;</span></span><br><span class="line"><span class="function"><span class="title">simd</span><span class="params">( U&amp;&amp; value )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> G &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">simd</span><span class="params">( G&amp;&amp; generator )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> U, <span class="keyword">class</span> Flags &gt;</span></span><br><span class="line"><span class="function"><span class="title">simd</span><span class="params">( <span class="type">const</span> U* mem, Flags flags )</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/lzl200110.github.io/../img/simd_constuctor.png" alt="构造函数"><br>作用分别是：</p><ul><li><code>广播构造</code>函数构造一个 simd，所有值均以 value 初始化。</li><li><code>生成器构造</code>函数构造一个 simd，其第 i 个元素以 generator(std::integral_constant&lt;std::size_t, i&gt;()) 初始化。</li><li><code>加载构造</code>函数构造 simd，使得对于范围 <code>[​0​, size())</code> 中的所有 i，其第 i 个元素以 static_cast<T>(mem[i]) 初始化。</li></ul><p>最后一个Flags 表示mem的对齐方式，标准库提供了3种对其方式，分别是：</p><ul><li><strong>element_aligned</strong>    指示mem对齐到元素</li><li><strong>vector_aligned</strong>     指示mem对齐到memory_alignment_v&lt;T, U&gt;，T为simd类型，U为mem缓冲区类型(可以理解为对齐到SIMD寄存器)。</li><li><strong>overaligned</strong>        指示mem对齐到N</li></ul><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;experimental/simd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> stdx = std::experimental;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stdx::native_simd&lt;<span class="type">int</span>&gt; a;<span class="comment">// 未初始化</span></span><br><span class="line">    a = <span class="number">1</span>;<span class="comment">// 将所有元素设为 1</span></span><br><span class="line">    <span class="function">stdx::native_simd&lt;<span class="type">int</span>&gt;  <span class="title">b</span><span class="params">([](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i; &#125;)</span></span>; <span class="comment">// &#123;0, 1, 2, 3, ...&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">alignas</span>(stdx::memory_alignment_v&lt;stdx::native_simd&lt;<span class="type">int</span>&gt;&gt;) std::array&lt;<span class="type">int</span>, stdx::native_simd&lt;<span class="type">int</span>&gt;::<span class="built_in">size</span>() +<span class="number">1</span>&gt; mem = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mem.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        mem[i] = i &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">stdx::native_simd&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(&amp;mem[<span class="number">0</span>], stdx::vector_aligned)</span></span>;  <span class="comment">// &#123;0, 1, 0, 1, ...&#125;</span></span><br><span class="line">    <span class="function">stdx::native_simd&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(&amp;mem[<span class="number">1</span>], stdx::element_aligned)</span></span>; <span class="comment">// &#123;1, 0, 1, 0, ...&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sum = a + b + c + d;</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sum.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        std::cout &lt;&lt; sum[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可能结果(AVX2 下)</span></span><br><span class="line"><span class="comment">// 2 3 4 5 6 7 8 9 </span></span><br></pre></td></tr></table></figure><p>上述代码中mem是长度为<code>stdx::native_simd&lt;int&gt;::size() +1</code> 的array，并且向量对齐到<code>stdx::native_simd&lt;int&gt;</code>(SSE对齐到 16Bytes,AVX2对其到 32Bytes,AVX512对其到64 Bytes)。</p><h3 id="load-store"><a href="#load-store" class="headerlink" title="load &amp; store"></a>load &amp; store</h3><p>simd提供了 <strong>copy_from</strong> 和 <strong>copy_to</strong> 来从<code>连续内存</code>加载或存储simd的元素，函数签名如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> U, <span class="keyword">class</span> Flags &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy_from</span><span class="params">( <span class="type">const</span> U* mem, Flags flags )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> U, <span class="keyword">class</span> Flags &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy_to</span><span class="params">( <span class="type">const</span> U* mem, Flags flags )</span></span>;</span><br></pre></td></tr></table></figure><p>上述函数表示将SIMD变量中内容store 到<code>[mem, mem + size()）</code>或者从该位置加载SIMD变量，Flag指示对齐方式，与构造函数中Flagn相同。</p><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>在构造函数函数中描述过，方法为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stdx::simd&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sum.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    std::cout &lt;&lt; sum[i] &lt;&lt; <span class="string">&#x27; </span></span><br></pre></td></tr></table></figure><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p>simd 提供了一系列算术运算，本质上为多个T同时运行，方法有：</p><ul><li>逐元素自增和自减<br>operator++ operator–</li><li>逐元素一元运算符<br>operator! operator~ operator+(取正) operator-(取负)</li><li>逐元素二元运算符<br>operator+ operator- operator* operator&#x2F; operator% operator&amp; operator| operator^ operator&lt;&lt; operator&gt;&gt;</li><li>逐元素复合二元运算符<br>operator+&#x3D; operator-&#x3D; operator*&#x3D; operator&#x2F;&#x3D; operator%&#x3D; operator&amp;&#x3D; operator|&#x3D; operator^&#x3D; operator&lt;&lt;&#x3D; operator&gt;&gt;&#x3D;</li><li>逐元素关系运算符<br>operator&#x3D;&#x3D; operator!&#x3D; operator&gt;&#x3D; operator&lt;&#x3D; operator&gt; operator&lt;</li></ul><p><em>注，算术运算返回一个simd对象(逐元素关系运算符返回simd_mask)</em></p><h3 id="规约函数-reduce、hmin、hmax"><a href="#规约函数-reduce、hmin、hmax" class="headerlink" title="规约函数 reduce、hmin、hmax"></a>规约函数 reduce、hmin、hmax</h3><p>标准库提供了规约函数来讲simd规约为一个数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 binary_op 上归约 x 中关联掩码元素为 true 的所有值。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> M, <span class="keyword">class</span> V, <span class="keyword">class</span> BinaryOperation &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> V::value_type</span></span><br><span class="line"><span class="function"><span class="title">reduce</span><span class="params">( <span class="type">const</span> const_where_expression&lt;M, V&gt;&amp; x,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">typename</span> V::value_type identity_element, BinaryOperation binary_op = &#123;&#125; )</span></span>;</span><br><span class="line"><span class="comment">//在 std::min 上归约 x 中关联掩码元素为 true 的所有值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> M, <span class="keyword">class</span> V &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> V::value_type</span></span><br><span class="line"><span class="function"><span class="title">hmin</span><span class="params">( <span class="type">const</span> const_where_expression&lt;M, V&gt;&amp; x )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//在 std::max 上归约 x 中关联掩码元素为 true 的所有值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> M, <span class="keyword">class</span> V &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> V::value_type</span></span><br><span class="line"><span class="function"><span class="title">hmax</span><span class="params">( <span class="type">const</span> const_where_expression&lt;M, V&gt;&amp; x )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// const_where_expression 包含mask、和simd数据，mask为true才需要规约</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;experimental/bits/simd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;experimental/simd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> stdx = std::experimental;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> V = stdx::native_simd&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    <span class="comment">// 生成数据</span></span><br><span class="line">    <span class="built_in">alignas</span>(stdx::memory_alignment_v&lt;V&gt;) std::array&lt;V::value_type, 1024&gt; data;</span><br><span class="line">    <span class="comment">// [0-1024)</span></span><br><span class="line">    std::<span class="built_in">iota</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 生成mask</span></span><br><span class="line">    stdx::native_simd_mask&lt;<span class="type">double</span>&gt; sm&#123;<span class="literal">true</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0u</span>z; i &lt; sm.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        sm[i] = i % <span class="number">2</span> == <span class="number">0</span>;<span class="comment">//[1,0,1,0....]</span></span><br><span class="line">    &#125;</span><br><span class="line">    V::value_type acc&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i += V::<span class="built_in">size</span>())</span><br><span class="line">        acc += stdx::<span class="built_in">reduce</span>(stdx::<span class="built_in">where</span>(sm, <span class="built_in">V</span>(&amp;data[i], stdx::vector_aligned)), std::plus&#123;&#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sum of data = &quot;</span> &lt;&lt; acc &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// res=0+2+4+6...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">alignas</span>(stdx::memory_alignment_v&lt;V&gt;) std::array&lt;<span class="type">double</span>, 4&gt; arr&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> w = <span class="built_in">V</span>(&amp;arr[<span class="number">0</span>], stdx::vector_aligned);</span><br><span class="line">    <span class="comment">// 在下表为偶数下规约</span></span><br><span class="line">    <span class="built_in">assert</span>(stdx::<span class="built_in">hmin</span>(stdx::<span class="built_in">where</span>(sm,w)) == <span class="number">2</span> <span class="keyword">and</span> stdx::<span class="built_in">hmax</span>(stdx::<span class="built_in">where</span>(sm,w)) == <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p><code>&lt;cmath&gt;</code>中除特殊数学函数之外的所有函数，都为 simd 提供了重载。 </p><p><em>注：当前标准库SIMD处于实验阶段，有很多内嵌原语没有提供，如shuffle等</em></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>设计两个4096*4096矩阵的乘法(cache、simd、omp角度优化,相较于单线程串行，可以达到600倍加速比(4核处理器))，略去，实现可参见代码<a href="../asset/matrix.cpp">matrix.cpp</a></p><h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><p>目标:将一张彩色图片变为灰度图片</p><ul><li>图片是32-bit ARGB类型(0xAARRGGBB)</li><li>灰度计算过程为<code>gray=（11*red+16*green+5*blue）/32</code></li><li>将计算后灰度存入原图片中，alpha 通道不变。</li></ul><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>定义Pixel结构体 <code>struct Pixel&#123;std::uint8_t b,g,r,a&#125;</code>(小端)，这样可以通过<strong>reinterpret_cast</strong>在uint32_t到Pixel快速转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pixel</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Pixel</span><span class="params">(<span class="type">uint32_t</span> v)</span> : a(v &gt;&gt; <span class="number">24</span>), r(v &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xFF</span>u), g(v &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xFF</span>u), b(v &amp; <span class="number">0xFF</span>u) &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(Pixel <span class="type">const</span>&amp; lsh, Pixel <span class="type">const</span>&amp; rsh) &#123;</span><br><span class="line">        <span class="keyword">return</span> lsh.b == rsh.b &amp;&amp; lsh.g == rsh.g &amp;&amp; lsh.r == rsh.r &amp;&amp; lsh.a == rsh.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint8_t</span> b, g, r, a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Image 类型 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Image = std::vector&lt;Pixel&gt;</span><br></pre></td></tr></table></figure><p>函数接口 <code>to_gray(Image &amp;img)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_gray1</span><span class="params">(Image&amp; img)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pixel : img) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> gray = (pixel.r * <span class="number">11</span> + pixel.g * <span class="number">16</span> + pixel.b * <span class="number">5</span>) / <span class="number">32</span>;</span><br><span class="line">        pixel.r = pixel.g = pixel.r = gray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::for_each + unseq 的执行策略</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_gray2</span><span class="params">(Image&amp; img)</span> </span>&#123;</span><br><span class="line">    std::for_each(std::execution::unseq, img.<span class="built_in">begin</span>(), img.<span class="built_in">end</span>(), [](Pixel&amp; pixel) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> gray = (pixel.r * <span class="number">11</span> + pixel.g * <span class="number">16</span> + pixel.b * <span class="number">5</span>) / <span class="number">32</span>;</span><br><span class="line">        pixel.r = pixel.g = pixel.r = gray;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>to_gary1和to_gray2都是对Image中的每个像素进行计算，to_gray2使用了C++的执行策略，但实际对运行事件影响不大。</p><h4 id="错误的SIMD优化"><a href="#错误的SIMD优化" class="headerlink" title="错误的SIMD优化"></a>错误的SIMD优化</h4><p>介绍SIMD优化之前，先看一个典型的错误实现，由于gray是r、g、b与比例进行reduce,一个可能的实现如下：<br><img src="/lzl200110.github.io/../img/non_invasive_simd.png" alt="non_invasive_simd"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> stdx = std::experimental;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> PixelSIMD   = stdx::fixed_size_simd&lt;<span class="type">uint8_t</span>, <span class="number">4</span>&gt;; <span class="comment">//一个像素就是一个4个int8的vector</span></span><br><span class="line"><span class="keyword">using</span> ImageSIMD   = std::vector&lt;PixelSIMD&gt;;</span><br><span class="line"><span class="keyword">using</span> Pixel32SIMD = stdx::fixed_size_simd&lt;<span class="type">uint32_t</span>, <span class="number">4</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> Pixel32Mask = PixelSIMD::mask_type;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> gray_coeff[<span class="number">4</span>]&#123;<span class="number">5</span>, <span class="number">16</span>, <span class="number">11</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">to_gray3</span><span class="params">(ImageSIMD&amp; img)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Pixel32Mask mask&#123;&#125;;</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; mask.size(); i++) &#123;</span></span><br><span class="line">    <span class="comment">//     mask[i] = i &lt; 3;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="function">Pixel32SIMD <span class="title">gray_vector</span><span class="params">(gray_coeff, stdx::element_aligned)</span></span>;<span class="comment">// 这里获取权重的vector，由于reduce会溢出，需要升级到int32</span></span><br><span class="line">    <span class="keyword">for</span> (PixelSIMD&amp; p8 : img) &#123;</span><br><span class="line">        <span class="type">const</span> Pixel32SIMD pixel = p8;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span>    gray  = stdx::<span class="built_in">reduce</span>(pixel * gray_vector) / <span class="number">32u</span>;<span class="comment">//规约</span></span><br><span class="line">        p8[<span class="number">0</span>] = p8[<span class="number">1</span>] = p8[<span class="number">2</span>] = gray; <span class="comment">// 这里应该运行一个simd双调选择(基于mask)，标准库目前没有，等待C++26吧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过SIMD将计算gray的过程变成对SIMD的规约，但通过比较时间，可以发现：<strong>程序变得更慢</strong>，原因很简单：程序并没有真正的实现数据并行化，我们使用4个不同的值，因此不得不在SIMD操作后进行规约，这个规约严重影响的程序的效率。</p><h4 id="正确的SIMD优化"><a href="#正确的SIMD优化" class="headerlink" title="正确的SIMD优化"></a>正确的SIMD优化</h4><p>我们期望的数据并行化应该是:<strong>多个像素点被同时处理</strong>。因此，我们可以将<br><code>gray = (pixel.r * 11 + pixel.g * 16 + pixel.b * 5) / 32</code><br>替换为<br><code>stdx::simd&lt;uint32_t&gt; r,g,b; </code><br><code>auto gary = (r * 11 + g * 16 + b * 5) / 32</code><br>上述<code>r、g、b</code> 是int32的向量，每个int32表示一个像素点某个通道(如r表示4个像素点的r通道)，通过simd可以对多个像素的rgb进行同时计算,如下图所示。<br><img src="/lzl200110.github.io/../img/simd_pall.png" alt="simd_pall"><br>问题也就转化为如何得到<code>r、g、b</code>SIMD向量，通过将Pixel定义为uint32,可以通过简单的移位和按位与操作集即可得到rgba分量(这里需要注意大小端的问题)。<br>代码实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Pixel32 = <span class="type">uint32_t</span>; <span class="comment">//0XFFAARRGGBB</span></span><br><span class="line"><span class="keyword">using</span> Image32 = std::vector&lt;<span class="type">uint32_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> PixelV  = stdx::native_simd&lt;Pixel32&gt;; <span class="comment">//Pixel的向量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_gray4</span><span class="params">(Image32&amp; img)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = img.<span class="built_in">begin</span>(); it &lt; img.<span class="built_in">end</span>(); it += PixelV::<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="function">PixelV     <span class="title">p</span><span class="params">(&amp;*it, stdx::element_aligned)</span></span>;  <span class="comment">//load</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> a     = p &gt;&gt; <span class="number">24</span>;             <span class="comment">// a通道的SIMD向量</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> r     = p &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xFF</span>u;     <span class="comment">// r通道的SIMD向量</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> g     = p &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xFF</span>u;      <span class="comment">// g通道的SIMD向量</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> b     = p &amp; <span class="number">0xFF</span>u;           <span class="comment">// b通道的SIMD向量</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> grayv = (r * <span class="number">11u</span> + g * <span class="number">16u</span> + b * <span class="number">5u</span>) / <span class="number">32u</span>; <span class="comment">// 计算gray的SIMD向量</span></span><br><span class="line">        p  = grayv | (grayv &lt;&lt; <span class="number">8</span>) | (grayv &lt;&lt; <span class="number">16</span>) | (a &lt;&lt; <span class="number">24</span>); </span><br><span class="line">        p.<span class="built_in">copy_to</span>(&amp;*it, stdx::element_aligned);  <span class="comment">// store</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设计算机使用的是<em>avx2</em>指令集，PixelV一次可以处理8个像素点，从而达到数据的并行化，上述代码在load、store是采用<em>element_aligned</em> 的标志，使用<em>vector_aligned</em>会加快速度。</p><h4 id="效率对比"><a href="#效率对比" class="headerlink" title="效率对比"></a>效率对比</h4><p>完整代码见<a href="../asset/simd_test.cpp">simd_test.cpp</a>，通过<code>g++ simd_test.cpp -std=c++23 -o main -mavx2 -O3</code>编译axv2指令下的程序，运行即可得到不同方案的时间消耗，一个可能的结果如图所示：</p><style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><p align="center"><font face="黑体" size=2.>效果对比</font></p><div class="center"><table><thead><tr><th align="center"></th><th align="center">to_gray1</th><th align="center">to_gray2</th><th align="center">to_gray3</th><th align="center">to_gray4</th></tr></thead><tbody><tr><td align="center"><strong>128K</strong></td><td align="center">0.62</td><td align="center">0.63</td><td align="center">1.27</td><td align="center"><strong>0.22</strong></td></tr><tr><td align="center"><strong>1M</strong></td><td align="center">2.3</td><td align="center">2.2</td><td align="center">2.5</td><td align="center"><strong>1.1</strong></td></tr><tr><td align="center"><strong>4M</strong></td><td align="center">7.9</td><td align="center">7.9</td><td align="center">11</td><td align="center"><strong>5.6</strong></td></tr><tr><td align="center"><strong>16M</strong></td><td align="center">37</td><td align="center">41</td><td align="center">37</td><td align="center"><strong>19</strong></td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;SIMD 的全称是 Single Instruction Multiple Data，中文名“单指令多数据”。&lt;code&gt;一个SIMD变量可以存储*</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="SIMD" scheme="http://example.com/tags/SIMD/"/>
    
    <category term="stdx" scheme="http://example.com/tags/stdx/"/>
    
  </entry>
  
  <entry>
    <title>Single单例模式</title>
    <link href="http://example.com/2023/12/17/Single%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/12/17/Single%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-17T15:23:05.000Z</published>
    <updated>2023-12-18T03:33:13.199Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式的理念非常简单，即应用<em>程序中只能有一个特定组件的实例</em>。例如：将数据库加载到内存中并提供只读的接口(浪费内存存储多个相同数据集没有意义)、日志接口将日历写入文件(通过单例可以传递日志类作为参数)。</p><h3 id="作为全局对象的单例"><a href="#作为全局对象的单例" class="headerlink" title="作为全局对象的单例"></a>作为全局对象的单例</h3><p>如何保证只有一个实例，是单例模式的核心，一个简单的方法是提供一个<strong>静态全局变量</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Database</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Databse database&#123;&#125;;</span><br></pre></td></tr></table></figure><p>所有依赖Database的代码都使用database，这样就是一个简单的单例，但存在部分问题，database的作用域是::,编译器会搜索出全局作用域::后的全部对象。</p><h3 id="单例模式的经典实现"><a href="#单例模式的经典实现" class="headerlink" title="单例模式的经典实现"></a>单例模式的经典实现</h3><p>之前的实现方式中，没有考虑额外对象创建的过程，Database不能保证全局只有一个实例，下面给出两种经典的实现。<br>双重校验锁模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Database&amp; <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> sin = instance.<span class="built_in">load</span>(std::memeory_order_acquire);</span><br><span class="line">        <span class="keyword">if</span>(!sin)&#123;</span><br><span class="line">            <span class="function">std::unqiue_lock <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            sin = instance.<span class="built_in">load</span>(std::memeory_order_relaxed);</span><br><span class="line">            <span class="keyword">if</span>(!sin)&#123;</span><br><span class="line">                sin = <span class="keyword">new</span> Database&#123;&#125;;</span><br><span class="line">                instance.<span class="built_in">store</span>(sin,std::memory_order_release);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *sin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Database</span>(<span class="type">const</span> Database&amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    Database&amp; <span class="keyword">operator</span>= (cosnt Database &amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Database</span>(<span class="type">const</span> Database&amp;&amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    Database&amp; <span class="keyword">operator</span>= (cosnt Database &amp;&amp;) =<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Database</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;Database*&gt; instance&#123;&#125;;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx&#123;&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Meyers单例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Database&amp; <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> Database database&#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> database;</span><br><span class="line">    &#125;       <span class="built_in">Database</span>(<span class="type">const</span> Database&amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    Database&amp; <span class="keyword">operator</span>= (cosnt Database &amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Database</span>(<span class="type">const</span> Database&amp;&amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    Database&amp; <span class="keyword">operator</span>= (cosnt Database &amp;&amp;) =<span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Database</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一种使用双重校验锁来保证互斥，避免出现创造两个实例的问题，第二种通过C++ 11的线程安全static来保证。</p><h3 id="每个线程单例"><a href="#每个线程单例" class="headerlink" title="每个线程单例"></a>每个线程单例</h3><p>每个线程单例与单例的构建过程类似，只需要将static变量声明为thread_local;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSingle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ThreadSingle&amp; <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">thread_local</span> <span class="type">static</span> ThreadSingle instance&#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="built_in">ThreadSingle</span>(<span class="type">const</span> ThreadSingle&amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    ThreadSingle&amp; <span class="keyword">operator</span>= (cosnt ThreadSingle &amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">ThreadSingle</span>(<span class="type">const</span> ThreadSingle&amp;&amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    ThreadSingle&amp; <span class="keyword">operator</span>= (cosnt ThreadSingle &amp;&amp;) =<span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">ThreadSingle</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用线程单例可以避免线程安全问题，因此可以使用map而非concurrent_map;</p><h3 id="单例模式存在的问题"><a href="#单例模式存在的问题" class="headerlink" title="单例模式存在的问题"></a>单例模式存在的问题</h3><p>单例模式可以保证特定组件只有一个实例，可以通过侵入性的依赖注入从而避免参数传递，但是存在着一些明显的问题：</p><ol><li>破坏程序的可测试性的可重构性，如在测试一个数据库的上层组件，通常将数据库变成stub(桩)来进行单元测试，由于databse的单例特性，不得不实现非依赖的代码来进行测试。</li><li>生命周期问题，<strong>单例模式本质是一个隐藏更好的静态全局变量</strong>，生命周期是由编译器的(全局的)，但若是析构函数使用其他单例对象，无法保证自己生命周期比其他对象长。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例模式的理念非常简单，即应用&lt;em&gt;程序中只能有一个特定组件的实例&lt;/em&gt;。例如：将数据库加载到内存中并提供只读的接口(浪费内存存储多个相同数据集没有意义)、日志接口将日历写入文件(通过单例可以传递日志类作为参数)。&lt;/p&gt;
&lt;h3 id=&quot;作为全局对象的单例&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="design pattern" scheme="http://example.com/categories/design-pattern/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Single" scheme="http://example.com/tags/Single/"/>
    
  </entry>
  
  <entry>
    <title>六大金刚</title>
    <link href="http://example.com/2023/12/16/%E5%85%AD%E5%A4%A7%E9%87%91%E5%88%9A/"/>
    <id>http://example.com/2023/12/16/%E5%85%AD%E5%A4%A7%E9%87%91%E5%88%9A/</id>
    <published>2023-12-16T08:40:44.000Z</published>
    <updated>2023-12-17T09:11:41.874Z</updated>
    
    <content type="html"><![CDATA[<p>任何一个 C++ 类,总会面临六大特殊函数的问题:</p><ul><li><strong>default 构造</strong></li><li><strong>copy 构造</strong></li><li><strong>move 构造</strong></li><li><strong>copy 赋值</strong></li><li><strong>move 赋值</strong></li><li><strong>析构</strong></li></ul><p>这六大金刚,一般可以分为4类：</p><ul><li>默认构造</li><li>copy 家族: copy 构造&#x2F;赋值</li><li>move 家族: move 构造&#x2F;赋值</li><li>析构</li></ul><p>本文将结合<em>存在性</em>来讲解他们之间的关系，并补充一些常见的观点。<br>我们在编写类时，应考虑如下规则：<strong>The Rule Of All or Nothing</strong> 。对于 <em>copy&#x2F;move 家族函数</em> 和 <em>析构函数</em>,要么全靠编译器默认生成,要么一旦对一个类考虑了其中一个,就应该同时考虑其它四个。要么<strong>全靠编译器实现，要么全部自己实现</strong>。</p><h2 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h2><p>所谓 <strong>存在性</strong>,单纯指在一个类中,它的定义是否存在,无论是用户自己定义的还是系统默认生成的。<br>对于任何一个特殊函数,其声明&#x2F;定义首先分为两大类别:</p><ol><li>用户显式声明&#x2F;定义<br>• 用户自定义<br>• 显式声明&#x2F;定义为 default<br>• 显式声明为 delete</li><li>编译器隐式声明&#x2F;定义<br>• 隐式声明&#x2F;定义为 default<br>• 隐式声明为 delete</li></ol><p>在用户显式定义的情况下, 对于任何一个特殊函数:</p><ol><li>如果用户显式定义了它(包括 &#x3D;default ),它都明确地存在。</li><li>如果用户显式删除了它 ( 通过 &#x3D;delete ),它都明确地不再存在。</li></ol><p>如果用户没有显式定义,编译器根据规则,决定隐式的定义或删除它。</p><h3 id="默认构造"><a href="#默认构造" class="headerlink" title="默认构造"></a>默认构造</h3><p><strong>只要用户 <span style="color: #7feee5;">显式声明</span>了构造函数(包括 copy&#x2F;move 构造,以及其他构造),系统就不会隐式定义默认构造。</strong><br>注意,<strong>用户显式声明</strong>并不是指用户自定义: 用户可以明确地声明 &#x3D; default 或者  &#x3D; delete ,但这些都不会生成默认构，当存在用户声明的构造函数时，用户仍可以通过关键词defaulth强制编译器生成默认构造函数。 </p><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line">    <span class="built_in">Thing</span>(Thing&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thing t&#123;&#125;; <span class="comment">// Error[No matching constructor for initialization of &#x27;Thing&#x27;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们声明了<code>Thing</code>的移动构造函数(即使是用&#x3D;default)，编译器依旧不会生成默认构造函数。</p><h3 id="拷贝构造-拷贝赋值"><a href="#拷贝构造-拷贝赋值" class="headerlink" title="拷贝构造(拷贝赋值)"></a>拷贝构造(拷贝赋值)</h3><p>• 如果<strong>用户没有显式声明任何构造函数列表</strong>,编译器会生成默认拷贝构造函数。<br>• 如果用户显式声明了构造函数列表,如果<strong>没有声明move家族</strong>，编译器也会生成一个默认拷贝构造函数。<br>• 拷贝赋值与拷贝构造情况相同；<br>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line"><span class="built_in">Thing</span>() &#123;&#125;</span><br><span class="line"><span class="comment">// 隐 式 生 成  copy构造 和 copy 赋值</span></span><br><span class="line"><span class="comment">// Thing(Thing const&amp;) = default;</span></span><br><span class="line"><span class="comment">// Thing&amp; operator=(Thing const&amp;) = default;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line"><span class="built_in">Thing</span>(Thing&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// copy 构造 和 copy 赋值 被 删 除</span></span><br><span class="line"><span class="comment">// Thing(Thing const&amp;) = delete;</span></span><br><span class="line"><span class="comment">// Thing&amp; operator=(Thing const&amp;) = delete;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line">Thing &amp; <span class="keyword">operator</span>=(Thing&amp;&amp;) =<span class="keyword">default</span></span><br><span class="line"><span class="comment">// copy 构造 和 copy 赋值 被 删 除</span></span><br><span class="line"><span class="comment">// Thing(Thing const&amp;) = delete;</span></span><br><span class="line"><span class="comment">// Thing&amp; operator=(Thing const&amp;) = delete;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span style="color: #de7f7f;"><em>注解: 隐式生成的拷贝构造,会依次调用所有父类和非静态成员的 copy 构造。</em></span></p><h3 id="移动构造-移动赋值"><a href="#移动构造-移动赋值" class="headerlink" title="移动构造(移动赋值)"></a>移动构造(移动赋值)</h3><p>如果用户明确声明了如下任何一个,系统都不会自动生成 移动构造:<br>• copy 构造<br>• copy 赋值<br>• move 赋值<br>• 析构函数<br>移动赋值和移动构造情况相同(<em>移动赋值、移动构造之间声明一个，编译器就会删除另外一个。如果你自己定义了一个，说明系统默认的与你想要的不符，这样的话，另外一个一般也不符，因此编译器选择删除</em>)。<br>如：</p><figure class="highlight c"><figcaption><span>p p</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Thing</span> &#123;</span></span><br><span class="line">Thing() &#123;&#125;</span><br><span class="line"><span class="comment">// 隐 式 生 成 move 构造 和 move 赋值</span></span><br><span class="line"><span class="comment">// Thing(Thing const&amp;&amp;) = default;</span></span><br><span class="line"><span class="comment">// Thing&amp; operator=(Thing const&amp;&amp;) = default;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Thing</span> &#123;</span></span><br><span class="line">～Thing() = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// move 构造 和 move 赋值 被 删 除</span></span><br><span class="line"><span class="comment">// Thing(Thing const&amp;&amp;) = delete;</span></span><br><span class="line"><span class="comment">// Thing&amp; operator=(Thing const&amp;&amp;) = delete;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Thing</span> &#123;</span></span><br><span class="line">Thing &amp; operator=(Thing&amp;&amp;) =<span class="keyword">default</span></span><br><span class="line"><span class="comment">// move 构造 和 删 除</span></span><br><span class="line"><span class="comment">// Thing(Thing const&amp;&amp;) = delete;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><span style="color: #de7f7f;"><em><strong>注解</strong>: 隐式生成的 move 构造,会依次调用所有父类和非静态成员的 move 构造。</em></span></p><p>这里再次重申：<br>对于<strong>move&#x2F;copy 家族</strong> ,编译器奉行的是 <strong>nothing or all</strong> 的策略:要么完全由编译器自动生成,要么完全由用户自己决定。</p><h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h3><p><strong>析构</strong> 在 <strong>六大金刚</strong> 中,处于食物链的顶端: 它只可能影响别人的存在性,而其它五位的存在性对其毫无影响。  </p><ul><li>一旦用户明确自定义了 <strong>析构</strong> ,则 <strong>move 家族</strong>就丧失了被编译器隐式生成的权利,除非程序员显式声明,否则,move 家族的两个成员都被标记为删除。</li><li><strong>析构</strong> 对于 <strong>copy 家族</strong>与 <strong>默认构造</strong>的存在性没有影响,析构被明确标记为删除，因为只创建不删除的对象,通过拷贝构造,或者通过拷贝复制进行修改,从语义和操作上并无问题。</li></ul><p>事实上,这背后的逻辑非常简单:<br>move 的典型应用场景为:将 <strong>将亡值</strong> 的内容移动给另外一个对象之后,自身很快就会被销毁,因而 move 操作与析构行为是高度相关的。  如果 析构是自定义的,那么 move 也应该由程序员自定义;编译器自作主张的默认生成是不负责任的。  而如果析构函数被程序员明确声明为删除,move却继续存在,这很明显违背了 move 本身的意义。</p><p><span style="color: #de7f7f;">*<strong>注解</strong>: 对于用户定义或隐式定义的析构函数，在析构函数体执行后，编译器会以声明的逆序调用该类的<strong>所有非静态非变体数据成员的析构函数</strong>，然后以构造的逆序调用所有直接<strong>非虚基类的析构函数</strong>（继而调用它的成员与它的基类的析构函数，以此类推），最后，如果此对象类型是最终派生类，那么调用所有虚基类的析构函数。</span></p><h3 id="共用规则"><a href="#共用规则" class="headerlink" title="共用规则"></a>共用规则</h3><p>前面已经介绍了特殊函数的存在性，但依旧存在一些问题,当编译器决定隐式定义某个特殊函数(&#x3D;defalt),但此时：比如,其某个<strong>非静态成员变量,或者某个父类将那个特殊函数删除了,或者访问被禁止了,则系统也会放弃对此特殊函数的生成,而隐式的将其声明为 delete</strong>，这类情况属于<strong>共用规则</strong>。</p><h2 id="常见的观点"><a href="#常见的观点" class="headerlink" title="常见的观点"></a>常见的观点</h2><ol><li>单参的构造函数应该声明为<strong>explicit</strong>，可以避免某些隐式转换或者二意性错误。</li><li>将析构函数声明为 &#x3D;delete 可以让对象只能分配到堆上。</li><li>不要在构造函数和析构函数中调用虚函数。出于保护机制，会得到非虚的调用。</li><li>在六大金刚之外，为类型实现<strong>swap</strong>和**operator&#x3D;&#x3D;**操作。</li><li>基类析构函数应该是public且virtual,要么是protected且非virtual。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任何一个 C++ 类,总会面临六大特殊函数的问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;default 构造&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;copy 构造&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;move 构造&lt;/strong&gt;&lt;/l</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="六大金刚" scheme="http://example.com/tags/%E5%85%AD%E5%A4%A7%E9%87%91%E5%88%9A/"/>
    
    <category term="构造函数" scheme="http://example.com/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
    <category term="析构函数" scheme="http://example.com/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Observer 观察者模式</title>
    <link href="http://example.com/2023/12/15/Observer%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/12/15/Observer%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-15T02:31:47.000Z</published>
    <updated>2023-12-15T08:10:30.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式似乎是一个经常被使用的设计模式，其核心思想是:当我要观察变化的对象时，不需要进行轮询，只需要在对象那里进行注册，当对象变化时，其自动提醒我发生了变化(执行我注册的回调)。</p><p>典型的代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">field_changed</span><span class="params">(T&amp; source, <span class="type">const</span> std::string&amp; field_name)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">(T&amp; source, <span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; obs : observers) &#123;</span><br><span class="line">obs-&gt;<span class="built_in">field_changed</span>(source, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">subscribe</span><span class="params">(Observer&lt;T&gt;* f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), f);</span><br><span class="line"><span class="keyword">if</span> (it == observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">observers.<span class="built_in">push_back</span>(f);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">unsubscribe</span><span class="params">(Observer&lt;T&gt;* f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">erase_if</span>(observers,</span><br><span class="line">                     [&amp;](Observer&lt;T&gt;* item) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> item == f; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;Observer&lt;T&gt;*&gt; observers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们要观察的是<code>Perosn</code>类的<code>age</code>属性,实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> : <span class="keyword">public</span> Observable&lt;Person&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">const</span> <span class="type">int</span> age)</span></span>;</span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsolePersonObserver</span> : <span class="keyword">public</span> Observer&lt;Person&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">field_changed</span><span class="params">(Person&amp; source, <span class="type">const</span> std::string&amp; field_name)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    : <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::set_age</span><span class="params">(<span class="type">const</span> <span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;age==age)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="built_in">notify</span>(*<span class="keyword">this</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Person::get_age</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsolePersonObserver::field_changed</span><span class="params">(Person&amp; source, <span class="type">const</span> std::string&amp; field_name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (field_name == <span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Person&#x27;s age have change to &quot;</span> &lt;&lt; source.<span class="built_in">get_age</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>Perosn</code>通过<code>set_age</code>修改年龄时，我们注册的<code>ConsolePersonObserver</code>会执行<code>field_changed</code>来处理。</p><p>观察者模式比较固定，下面给出需要注意的几个要点。</p><h3 id="记录observers的容器"><a href="#记录observers的容器" class="headerlink" title="记录observers的容器"></a>记录observers的容器</h3><p>上面代码在<code>Observable</code>接口在中使用<code>vector</code>来记录注册的观察者,导致我们在<code>unsubscribe</code>时需要通过遍历来查找。</p><p>选择存储观察者的容器时需要考虑以下几点：</p><ul><li>是否允许重复订阅</li><li>notify需不需要按订阅顺序</li><li>观察者是否有不同的优先级</li></ul><p>几个可能的方案：vector、set、list+index。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>上述代码没有考虑多线程的问题，如果同时<code>unsubscribe</code>和<code>subscribe</code>被调用，vector很有可能出现意想不到的结果。<br>加锁的实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">(T&amp; source, <span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"><span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; obs : observers) &#123;</span><br><span class="line">obs-&gt;<span class="built_in">field_changed</span>(source, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">subscribe</span><span class="params">(Observer&lt;T&gt;* f)</span> </span>&#123;</span><br><span class="line"><span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), f);</span><br><span class="line"><span class="keyword">if</span> (it == observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">observers.<span class="built_in">push_back</span>(f);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">unsubscribe</span><span class="params">(Observer&lt;T&gt;* f)</span> </span>&#123;</span><br><span class="line"><span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">erase_if</span>(observers,</span><br><span class="line">                     [&amp;](Observer&lt;T&gt;* item) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> item == f; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;Observer&lt;T&gt;*&gt; observers;</span><br><span class="line">std::mutex mtx&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一个方案就是使用线程安全的vector(如tbb中的concurrent_vector),这样可以避免我们手动管理锁，但无法保证顺序(一个一个添加的两个对象不能保证按顺序得到通知)。</p><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>上文提到的加锁方案解决了多线程的问题，但是可能导致死锁，假设<code>field_changed</code>函数中可能会调用<code>unsubscribe</code>,调用链如下：<br><code> notify() ----&gt; field_changed() ----&gt; unsubscribe()</code><br>由于<code>notify</code>时进行了<code>lock</code>操作，<code>unsubscribe</code>会尝试获取一个已经获得的锁。这就是<em>可重入</em>的问题。</p><ul><li><p>可以放弃从集合删除元素，仅仅把其设为nullptr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">unsubscribe</span><span class="params">(Observer&lt;T&gt;* f)</span> </span>&#123;</span><br><span class="line"><span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(observers.<span class="built_in">begin</span>(),observers.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(it!=observers.<span class="built_in">end</span>())&#123;</span><br><span class="line">*it=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以在notify时copy一份observers</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">(T&amp; source, <span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">std::vector&lt;Observer&lt;T&gt;*&gt; observers_cpoy;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">observers_cpoy = observers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; obs : observers_cpoy) &#123;</span><br><span class="line">obs-&gt;<span class="built_in">field_changed</span>(source, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以禁止重入，不提供可重入的接口。</p></li></ul><p>对于可重入的观察者，将<code>mutex</code>替换为<code>recursivee_mutex</code>往往是可以的，能够一定程度上避免死锁的产生。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>观察者模式是被广泛使用的设计模式，在实现时，需要考虑以下几个方面：</p><ul><li><strong>希望为观察者传递什么信息</strong>? <ul><li>例如，处理域成员(属性)的变化，则可以包含属性的名称和对应的值。</li></ul></li><li><strong>如何处理取消订阅的接口</strong>?<ul><li>如果不提供取消订阅的接口，那么也就不存在可重入的问题了，大大简化了实现。</li><li>如果提供取消订阅的接口，是直接移除，还是先标记后移除?</li><li>如果不喜欢原始指针做分发，可以使用weak_ptr存储观察者。</li></ul></li><li><strong>观察者会被多线程调用吗</strong>?如果需要，则需要管理订阅列表<ul><li>在所有相关代码中加锁，注意避免死锁</li><li>使用线程安全的容器，但可能会损失按序相关的特性。</li></ul></li><li><strong>允许观察者多次注册吗</strong>? <ul><li>如果允许，那么不能使用set来存储观察者</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h2&gt;&lt;p&gt;观察者模式似乎是一个经常被使用的设计模式，其核心思想是:当我要观察变化的对象时，不需要进行轮询，只需要在对象那里进行</summary>
      
    
    
    
    <category term="design pattern" scheme="http://example.com/categories/design-pattern/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="观察者模式" scheme="http://example.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Observer" scheme="http://example.com/tags/Observer/"/>
    
  </entry>
  
  <entry>
    <title>Builder 建造者模式</title>
    <link href="http://example.com/2023/12/14/Builder%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/12/14/Builder%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-14T08:40:17.000Z</published>
    <updated>2023-12-16T08:13:41.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p><strong>建造者模式</strong>主要关注复杂对象的创建过程，复杂对象指难以通过调用单个构造函数来创建的对象。这些对象本身可能由其他对象组成，并且可能涉及不太明显的逻辑，因此需要专门设计单独的组件来创建。</p><p>案例 Web 界面</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>希望构建一个呈现web页面的组件，首先，我们将输出一个简单的无序列表，其中有两个item，其中包含单词hello和world。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string words[] = &#123; <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line">ostringstream oss;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;&lt;ul&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> w : words)</span><br><span class="line">oss &lt;&lt; <span class="string">&quot; &lt;li&gt;&quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot;&lt;/li&gt;&quot;</span>;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;&lt;/ul&gt;&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><p>上述实现明显不够灵活，创建列表后，难以向其中添加元素。可以使用OOP定义一个<code>HtmlElement</code>类来存储信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HemlElement</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    string text;</span><br><span class="line">    vector&lt;HemlElement&gt; elements;</span><br><span class="line">    <span class="built_in">HtmlElement</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">HtmlElement</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; text)</span><br><span class="line">    : <span class="built_in">name</span>(name), <span class="built_in">text</span>(text) &#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(<span class="type">int</span> indent = <span class="number">0</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pretty-print the contents</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于上述实现，可以用一种更加合理的方式创建列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string world[]=&#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">HtmlElement list&#123;<span class="string">&quot;ul&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> w:words)&#123;</span><br><span class="line">    list.elements.<span class="built_in">emplace_back</span>(HtmlElement&#123;<span class="string">&quot;li&quot;</span>,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(list.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><p>通过该方法可以实现条目列表，但是构建HtmlElement的过程比较麻烦，我么可以将HtmlElement的构造用建造者模式进行改进。</p><h3 id="简单建造者"><a href="#简单建造者" class="headerlink" title="简单建造者"></a>简单建造者</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HtmlBuilder</span> &#123;</span><br><span class="line">    HtmlElement root;</span><br><span class="line">    <span class="built_in">HtmlBuilder</span>(string root_name) &#123; root.name = root_name; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_child</span><span class="params">(string child_name, string child_text)</span> </span>&#123;</span><br><span class="line">        HtmlElement e&#123;child_name, child_text&#125;;</span><br><span class="line">        root.elements.<span class="built_in">emplace_back</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root.<span class="built_in">str</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个用于构建HTML元素的专用组件。add_child()方法是用来向当前元素添加额外的子元素的方法。它可以如下使用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HtmlBuilder builder&#123; <span class="string">&quot;ul&quot;</span> &#125;;</span><br><span class="line">builder.<span class="built_in">add_child</span>(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">builder.<span class="built_in">add_child</span>(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cout &lt;&lt; builder.<span class="built_in">str</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="流式建造者"><a href="#流式建造者" class="headerlink" title="流式建造者"></a>流式建造者</h3><p>add_child() 返回空值,返回 this 即可实现链式调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HtmlBuilder&amp; <span class="title">add_child</span><span class="params">(string child_name, string child_text)</span> </span>&#123;</span><br><span class="line">    HtmlElement e&#123;child_name, child_text&#125;;</span><br><span class="line">    root.elements.<span class="built_in">emplace_back</span>(e);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HtmlBuilder builder&#123; <span class="string">&quot;ul&quot;</span> &#125;;</span><br><span class="line">builder.<span class="built_in">add_child</span>(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;hello&quot;</span>).<span class="built_in">add_child</span>(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cout &lt;&lt; builder.<span class="built_in">str</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="向用户表达意图"><a href="#向用户表达意图" class="headerlink" title="向用户表达意图"></a>向用户表达意图</h3><p>有时我们希望用户只能使用我们提供的方法，而不能使用构造函数，可以<strong>将构造函数声明为protected,将Builder声明为n友元,并提供静态的create方法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HtmlElement</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string text;</span><br><span class="line">    vector&lt;HtmlElement&gt; elements;</span><br><span class="line">    <span class="function"><span class="type">static</span> HtmlBuilder <span class="title">create</span><span class="params">(<span class="type">const</span> string&amp; root_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HtmlBuilder&#123;root_name&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:  <span class="comment">// hide all constructors</span></span><br><span class="line">    <span class="built_in">HtmlElement</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">HtmlElement</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; text)</span><br><span class="line">        : name&#123;name&#125;, text&#123;text&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面例子中通过<code>create</code>方法构造了<code>HtmlBuilder</code>对象，可以通过提供<code>HtmlBuilder的HtmlElement的隐式转换函数</code>来优美的获得HtmlElement对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HtmlBuilder</span> &#123;</span><br><span class="line">    HtmlElement root;</span><br><span class="line">    <span class="built_in">HtmlBuilder</span>(string root_name) &#123; root.name = root_name; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_child</span><span class="params">(string child_name, string child_text)</span> </span>&#123;</span><br><span class="line">      HtmlElement e&#123;child_name, child_text&#125;;</span><br><span class="line">      root.elements.<span class="built_in">emplace_back</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root.<span class="built_in">str</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">HtmlElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(root);</span><br><span class="line">&#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HtmlElement elem = HtmlElement::<span class="built_in">create</span>(<span class="string">&quot;ul&quot;</span>).<span class="built_in">add_child</span>(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;hello&quot;</span>).<span class="built_in">add_child</span>(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;world&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>构造器模式的目的是简化复杂对象或一系列对象的构建过程，从而单独定义构成该复杂对象的各个组件的方法。构造器模式通常有以下特点：</p><ul><li>构造器模式可以通过<strong>流式接口调用</strong>来实现复杂的构建过程。为实现给接口，构造器的函数要返回thisn指针或*this对象。</li><li>为了强制用户使用我们提供的构造者，可以将<strong>构造函数声明为不可见，并定义静态的create方法返回构造器</strong>。</li><li>使用构造器的目的是获得对象，通过<strong>定义构造器到对象的转换</strong>是有益的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; title=&quot;建造者模式&quot;&gt;&lt;/a&gt;建造者模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;建造者模式&lt;/strong&gt;主要关注复杂对象的创建过程，复杂对象指难以通过调用单个构造函数来创建的对</summary>
      
    
    
    
    <category term="design pattern" scheme="http://example.com/categories/design-pattern/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="访问者模式" scheme="http://example.com/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Builder" scheme="http://example.com/tags/Builder/"/>
    
  </entry>
  
  <entry>
    <title>SOLID设计原则</title>
    <link href="http://example.com/2023/12/14/SOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2023/12/14/SOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2023-12-14T03:43:36.000Z</published>
    <updated>2023-12-14T05:42:22.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SOLID设计原则"><a href="#SOLID设计原则" class="headerlink" title="SOLID设计原则"></a>SOLID设计原则</h1><p>SOLID 是面向对象设计五大重要原则的首字母缩写，当我们设计类和模块时，遵守 SOLID 原则就如同它的名字一样：(solid，可靠的)，可以让软件更加稳定、灵活和健壮。</p><h2 id="Single-Responsibility-Principle（SRP）：单一职责原则"><a href="#Single-Responsibility-Principle（SRP）：单一职责原则" class="headerlink" title="Single Responsibility Principle（SRP）：单一职责原则"></a>Single Responsibility Principle（SRP）：单一职责原则</h2><p>每个类只有一个责任，只有一个改变的理由。让一个类或者一个模块专注于单一的功能，减少功能之间的耦合程度。这样做在需要修改某个功能时，就不会影响到其他的功能。 </p><p>案例:日记Journal<br>希望实现一个日记，其中包含标题和多个条目</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Journal</span>&#123;</span><br><span class="line">    string title;</span><br><span class="line">    vector&lt;string&gt; entries;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Journal</span><span class="params">(<span class="type">const</span> string&amp; title)</span> : title&#123;</span>title&#125; &#123;&#125;</span><br><span class="line">    <span class="comment">// 添加条目</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Journal::add</span><span class="params">(<span class="type">const</span> string&amp; entry)</span></span>&#123;</span><br><span class="line">       <span class="type">static</span> <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">       entries.<span class="built_in">push_back</span>(boost::<span class="built_in">lexical_cast</span>&lt;string&gt;(count++)</span><br><span class="line">            + <span class="string">&quot;: &quot;</span> + entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在希望添加将日记持久化到文件的功能，一个简单的实现方式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Journal::save</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s:entries)&#123;</span><br><span class="line">        ofs&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现将持久化功能交给日志，然而日志的责任是<em>保存日志条目</em>，而不是把它们写道磁盘上。如果将持久化的功能添加到 Journal 中，后续对持久化的方法进行修改(写到云端等)，每个受影响的类中需要进行<em>大量的微小的更改</em>。<br>较为正确的实现方式为，单独创建一个类实现持久化功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersistenceManager</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">save</span><span class="params">(<span class="type">const</span> Journal&amp; j,<span class="type">const</span> string &amp; filename)</span></span>&#123;</span><br><span class="line">        <span class="function">ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s:j.entries)&#123;</span><br><span class="line">            ofs&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以：单一职责原则的含义为：<strong>每个类只有一个责任，只有一个改变的理由，相同的职责放到一起，不同的职责分解到不同的接口和实现中去</strong>。</p><h2 id="Open-Closed-Principle（OCP）：开闭原则"><a href="#Open-Closed-Principle（OCP）：开闭原则" class="headerlink" title="Open Closed Principle（OCP）：开闭原则"></a>Open Closed Principle（OCP）：开闭原则</h2><p>开闭原则含义是 <strong>类应该是对扩展开放，对修改关闭的</strong>，一个类独立之后就不应该去修改它，而是以扩展的方式适应新需求。<br>案例 数据过滤：</p><p>在数据库中，拥有一个范围的产品，每个产品具有颜色和尺寸。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum class Color&#123;</span><br><span class="line">    Red,</span><br><span class="line">    Blue,</span><br><span class="line">    Green</span><br><span class="line">&#125;;</span><br><span class="line">enum class Size&#123;</span><br><span class="line">    Small,</span><br><span class="line">    Middle,</span><br><span class="line">    Large</span><br><span class="line">&#125;;</span><br><span class="line">struct Product&#123;</span><br><span class="line">    string name;</span><br><span class="line">    Color color;</span><br><span class="line">    Size size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，希望给产品添加按照颜色过滤功能。可能制作如下的过滤器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct ProductFilter &#123;</span><br><span class="line">    using Items  = vector&lt;Product*&gt;;</span><br><span class="line">&#125;</span><br><span class="line">ProductFilter::Items ProductFilter::by_color(Item items,Color color)&#123;</span><br><span class="line">    Items result;</span><br><span class="line">    for(auto &amp; i:items)&#123;</span><br><span class="line">        if(i-&gt;color==color)&#123;</span><br><span class="line">            result.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过段时间后，需要按照尺寸进行过滤，可能添加以下功能，然后<em>重新编译文件</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ProductFilter::Items ProductFilter::by_size(Item items,Size size)&#123;</span><br><span class="line">    Items result;</span><br><span class="line">    for(auto &amp; i:items)&#123;</span><br><span class="line">        if(i-&gt;size==size)&#123;</span><br><span class="line">            result.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在添加按照尺寸和颜色过滤功能，继续添加代码？<br>在该场景中，<strong>开闭原则</strong>或许是有用的，该原则声明<em><strong>类型是对扩展开放，对修改关闭的</strong></em>。<br>具体而言，我们希望过滤是可扩展的(可能在其他的编译单元中)，而不必修改现有的代码(可能以及发布)。<br>将过滤器分为两个部分：<em>筛选器</em> 和 <em>规范</em>：对规范接口做一个简单的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; </span><br><span class="line">struct Specification&#123;</span><br><span class="line">   virtual bool is_satisfied(T* item) = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>T是一个模板类型，在上例中为Product。<br>然后，需要一个基于Specification的过滤方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct Filter&#123;</span><br><span class="line">    virtual vector&lt;T*&gt; filter(vector&lt;T*&gt; items,Specification&lt;T&gt; &amp;spec) = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>filter 函数接受所有项目和一个规范，并返回符合规范的所有项目。基于前述，改进的过滤器的实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BetterFilter</span> : Filter&lt;Product&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">vector&lt;Product*&gt; <span class="title">filter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;Product*&gt; items,</span></span></span><br><span class="line"><span class="params"><span class="function">        Specification&lt;Product&gt;&amp; spec)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;Product*&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : items)</span><br><span class="line">            <span class="keyword">if</span> (spec.<span class="built_in">is_satisfied</span>(p))</span><br><span class="line">                result.<span class="built_in">push_back</span>(p);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的Specification的实现为：相当与一个function函数对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ColorSpecification</span> : Specification&lt;Product&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Color color;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ColorSpecification</span><span class="params">(<span class="type">const</span> Color color)</span> :</span></span><br><span class="line"><span class="function">    color&#123;</span>color&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_satisfied</span><span class="params">(Product* item)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item-&gt;color == color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>开闭原则：<strong>你不需要返回你已经编写和测试过的代码，并对其进行更改</strong>。也就对应对修改关闭、对扩展开放。<br>上述实例中：我们制定了 Specification 和 Filter，从那时起，我们所要做的就是实现任何一个接口（不需要修改接口本身，也不需要修改Product类）来实现新的过滤机制,同时也可e结合<strong>组合模式</strong> 来实现组合过滤。</p><h2 id="Liskov-Substitution-Principle（LSP）：里氏替换原则"><a href="#Liskov-Substitution-Principle（LSP）：里氏替换原则" class="headerlink" title="Liskov Substitution Principle（LSP）：里氏替换原则"></a>Liskov Substitution Principle（LSP）：里氏替换原则</h2><p>里氏替换原则定义为：如果一个接口可以接受类型为 Parent 的对象，那么它应该同样地可以接受类型为 Child 的对象，而不会有任何破坏<br>里氏替换原则的核心是：对<em>父类有效的方法对子类同样有效</em></p><h2 id="Interface-Segregation-Principle（ISP）：接口隔离原则"><a href="#Interface-Segregation-Principle（ISP）：接口隔离原则" class="headerlink" title="Interface Segregation Principle（ISP）：接口隔离原则"></a>Interface Segregation Principle（ISP）：接口隔离原则</h2><p>接口隔离原则定义为： <strong>将复杂接口的部分分隔成单独的接口，以避免迫使实现者实现他们并不真正需要的功能</strong><br>案例：Contianer<br>你实现了容器一个接口，同时支持list、vector、tree的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Contianer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//list 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">get</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">put</span><span class="params">(T&amp;)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(Position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//vector 操作</span></span><br><span class="line">    <span class="keyword">virtual</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span>) =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//tree 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">balance</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当你实现该接口时，不得不实现3个相关的概念(可能你只需要vector相关的方法)，却不得不实现全部的方法。</p><h2 id="Dependence-Inversion-Principle（DIP）：依赖反转原则"><a href="#Dependence-Inversion-Principle（DIP）：依赖反转原则" class="headerlink" title="Dependence Inversion Principle（DIP）：依赖反转原则"></a>Dependence Inversion Principle（DIP）：依赖反转原则</h2><p>高级模块不应该依赖低级模块，而是依赖抽象接口，抽象接口不应该依赖细节，细节应该依赖抽象接口。<br>案例：日志类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ILogger</span>&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ILogger</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">int</span> level,<span class="type">const</span> string &amp;s)</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConsoleLogger</span> : ILogger&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">int</span> level,<span class="type">const</span> string &amp;s)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">set_log_color</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Log :&quot;</span>&lt;&lt;s&lt;&lt;std::endl;</span><br><span class="line">        <span class="built_in">close_log_color</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>依赖Log 模块的上层不应该依赖ConsoleLogger，应该靠ILogger*，在构造时传入相应的依赖。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SOLID设计原则&quot;&gt;&lt;a href=&quot;#SOLID设计原则&quot; class=&quot;headerlink&quot; title=&quot;SOLID设计原则&quot;&gt;&lt;/a&gt;SOLID设计原则&lt;/h1&gt;&lt;p&gt;SOLID 是面向对象设计五大重要原则的首字母缩写，当我们设计类和模块时，遵守 SO</summary>
      
    
    
    
    <category term="design pattern" scheme="http://example.com/categories/design-pattern/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="SOLID" scheme="http://example.com/tags/SOLID/"/>
    
    <category term="设计原则" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Visitor 访问者模式</title>
    <link href="http://example.com/2023/12/14/Visitor%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/12/14/Visitor%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-13T16:55:14.000Z</published>
    <updated>2023-12-15T08:10:27.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>对于具有层次类型的对象类型(有继承关系)，为结构中所有类型添加方法需要大幅度的修改代码，若进行提前规划，使用访问者模式可避免修改大量代码。</p><p>假设在解析数学表达式，该数学表达式又double类型的值和运算符组成。如：<br><code>(1.0+(2.0+3.0))</code><br>该表达式可以表示为如下的层次结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Express</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Express</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleExpress</span> : <span class="keyword">public</span> Express &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DoubleExpress</span><span class="params">(<span class="type">double</span> v)</span></span></span><br><span class="line"><span class="function">    : value(v) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> value&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddtionExpress</span> : <span class="keyword">public</span> Express &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AddtionExpress</span>(Express* l, Express* r)</span><br><span class="line">    : <span class="built_in">left</span>(l)</span><br><span class="line">    , <span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">~<span class="built_in">AddtionExpress</span>() <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="keyword">delete</span> left;</span><br><span class="line"><span class="keyword">delete</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Express *left, *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种层次结构下，若需要向<strong>Express的继承者</strong>添加一些方法，如，<code>打印表达式</code>、<code>对表达式进行求值</code>，该如何实现？</p><h2 id="侵入式访问者"><a href="#侵入式访问者" class="headerlink" title="侵入式访问者"></a>侵入式访问者</h2><p>上述问题中，不同的类有不同实现，使用多态可以很好得而达到要求，侵入式的访问者通过向所有类中添加一个多态方法来实现新功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Express</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Express</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(std::ostringstream&amp; oss)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleExpress</span> : <span class="keyword">public</span> Express &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DoubleExpress</span><span class="params">(<span class="type">const</span> <span class="type">double</span> v)</span></span></span><br><span class="line"><span class="function">    : value(v) &#123;</span>&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::ostringstream&amp; oss)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">oss &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> value&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddtionExpress</span> : <span class="keyword">public</span> Express &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AddtionExpress</span>(Expression* <span class="type">const</span> left, Expression* <span class="type">const</span> right)</span><br><span class="line">    : <span class="built_in">left</span>(l)</span><br><span class="line">    , <span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::ostringstream&amp; oss)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">left-&gt;<span class="built_in">print</span>(oss);</span><br><span class="line">oss &lt;&lt; <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">right-&gt;<span class="built_in">print</span>(oss);</span><br><span class="line">        oss &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">AddtionExpress</span>() <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="keyword">delete</span> left;</span><br><span class="line"><span class="keyword">delete</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Express *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Express* e = <span class="keyword">new</span> AddtionExpress&#123;</span><br><span class="line">    <span class="keyword">new</span> DoubleExpress&#123;<span class="number">1.0f</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> AddtionExpress&#123;<span class="keyword">new</span> DoubleExpress&#123;<span class="number">2.0f</span>&#125;, <span class="keyword">new</span> DoubleExpress&#123;<span class="number">3.0f</span>&#125;&#125;&#125;;</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    e-&gt;<span class="built_in">print</span>(oss);</span><br><span class="line">    std::cout&lt;&lt;oss.<span class="built_in">str</span>()&lt;&lt;std::endl;<span class="comment">//print (1+(2+3))</span></span><br><span class="line">    <span class="keyword">delete</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码似乎很好的完成了需求，似乎还很好的用到了面向对象的方法：多态。<br>但是却有这明显弊端：</p><ul><li>如果层次结构中中多个类(20个)，需要添加一个新的方法时(求值)，我们不得不再次修改<strong>全部</strong>的代码(bad),这是一个复杂的工程。</li></ul><p>正真的原因在于<strong>单一职责原则</strong>，<code>打印</code>功能h是一个单独的职责，与其让所有表达式提供print接口，不如引入一个负责打印功能的类ExpressPrinter。然后，还可以引入一个ExpressaEvaluator,它负责求值的功能。</p><h2 id="反射式访问者"><a href="#反射式访问者" class="headerlink" title="反射式访问者"></a>反射式访问者</h2><p>引入ExpressPrinter后，代码结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Expression</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleExpress</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DoubleExpress</span><span class="params">(<span class="type">const</span> <span class="type">double</span> v)</span></span></span><br><span class="line"><span class="function">    : value(v) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdditionExpress</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span>;</span><br><span class="line"><span class="built_in">AdditionExpress</span>(Expression* <span class="type">const</span> left, Expression* <span class="type">const</span> right)</span><br><span class="line">    : <span class="built_in">left</span>(left)</span><br><span class="line">    , <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">~<span class="built_in">AdditionExpress</span>() <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="keyword">delete</span> left;</span><br><span class="line"><span class="keyword">delete</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Expression *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Expression* e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> de = <span class="built_in">dynamic_cast</span>&lt;DoubleExpress*&gt;(e)) &#123;</span><br><span class="line">oss &lt;&lt; de-&gt;value;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span> ae = <span class="built_in">dynamic_cast</span>&lt;AdditionExpress*&gt;(e)) &#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(ae-&gt;left);</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(ae-&gt;right);</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::ostringstream oss&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> e = <span class="keyword">new</span> AdditionExpress&#123;</span><br><span class="line">    <span class="keyword">new</span> DoubleExpress&#123;<span class="number">1</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> AdditionExpress&#123;<span class="keyword">new</span> DoubleExpress&#123;<span class="number">2</span>&#125;, <span class="keyword">new</span> DoubleExpress&#123;<span class="number">3</span>&#125;&#125;&#125;;</span><br><span class="line">ExpressionPrinter ep;</span><br><span class="line">ep.<span class="built_in">print</span>(e);</span><br><span class="line">std::cout &lt;&lt; ep.<span class="built_in">str</span>() &lt;&lt; std::endl; <span class="comment">//print (1+(2+3))</span></span><br><span class="line">    <span class="keyword">delete</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过引入ExpressionPrinter实现打印功能，我们不需要大幅度修改已有代码，只需要注意访问权限，将ExpressionPrinter说明为Express的有缘即可。<br>在看ExpressionPrinter，其print函数接受一个<strong>基类指针</strong>，但我们需要根据指针实际类型来执行不同的方法。于是，<strong>反射</strong>在这里就h登场，通过<strong>dynamic_cast</strong>来判断基类指针是否为某一类型，通过<strong>穷举全部子类</strong>即可得到指针的实际类型，然后根据不同类型调用不同的打印方法。<br>上述代码也存在明显缺点:</p><ul><li>在进行<code>dynamic_cast</code>反射时，我们要保证：1、全部子类被包含，不能有遗漏；2、先检查子类，在检查父类。<br>若先判断了父类，那么<code>dynamic_cast</code>将子类指针转为父类指针是会成功的，这大概率会引起一个错误。</li></ul><h2 id="二重分发"><a href="#二重分发" class="headerlink" title="二重分发"></a>二重分发</h2><p>回顾<code>反射式访问者</code>，可以发现相较于<code>侵入式访问者</code>，由于其缺少了<strong>多态</strong>,导致我们不得不根据反射来判断类型，若有多态的vtable,我们可以交由多态来判断类型执行相应的函数。<br>为此，这里引入<strong>二重分发</strong>的概念，它是经典访问者的关键。</p><p>“分发”是确定要调用哪个函数的问题—-具体来说指需要多少信息才能调用正确的函数。<br>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stuff</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> : Stuff&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> : Stuff&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Foo* foo)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Bar* bar)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果创建一个普通的Foo对象，那么其调用func()是没有任何问题的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo* f = <span class="keyword">new</span> Foo&#123;&#125;;</span><br><span class="line"><span class="built_in">func</span>(f);</span><br></pre></td></tr></table></figure><p>但是，如果决定将其转换为基类指针，编译器将不知道调用哪个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stuff* f = <span class="keyword">new</span> Foo&#123;&#125;;</span><br><span class="line"><span class="built_in">func</span>(f);  <span class="comment">//oops! 调用func(Foo*)还是func(Bar*)呢？</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从多态角度考虑以下，有没有不进行RTTI(dynamic_cast)检查的情况下，使系统调用正确的重载函数？答案显然是有的。<br>可以看到，当通过<code>Stuff</code>调用某个函数时，若这个函数是多态的，可以直接分发的正确的组件，而组件又可以调用正确的函数重。这就被称为<strong>二重分发</strong>，因为：</p><ul><li>首先，我们在实际的对象上进行了一次多态调用。</li><li>在多态调用的内部，由调用了函数重载。(在对象内部，this指针拥有正确的类型，因此可以调用正确的函数重载)。<br>二重分发代码如下:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stuff</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> : Stuff&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> : Stuff&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Foo* foo)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Bar* bar)</span></span>&#123;&#125;</span><br><span class="line">Stuff* s = <span class="keyword">new</span> Foo&#123;&#125;;</span><br><span class="line">s-&gt;<span class="built_in">call</span>();<span class="comment">//正确调用 func(Foo*);</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="经典访问者"><a href="#经典访问者" class="headerlink" title="经典访问者"></a>经典访问者</h2><p>访问者的经典实现就是使用<strong>二重分发</strong>。命名有如下规则：</p><ul><li>访问者成员函数通常命名为visit();</li><li>被访问者实现的成员函数通常称为accept();<br>现在，让我们实现基于<strong>二重分发</strong>的经典访问者,由于ExpressVisitor 和Expression相互引用，我们无法将其放到一个头文件中，需要将部分实现放到.cpp文件中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// visitor.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressVisitor</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(ExpressVisitor* visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Expression</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleExpress</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DoubleExpress</span><span class="params">(<span class="type">const</span> <span class="type">double</span> v)</span></span></span><br><span class="line"><span class="function">    : value(v) &#123;</span>&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(ExpressVisitor* visitor)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="type">double</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdditionExpress</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">AdditionExpress</span>(Expression* <span class="type">const</span> left, Expression* <span class="type">const</span> right)</span><br><span class="line">    : <span class="built_in">left</span>(left)</span><br><span class="line">    , <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">~<span class="built_in">AdditionExpress</span>() <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="keyword">delete</span> left;</span><br><span class="line"><span class="keyword">delete</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(ExpressVisitor* visitor)</span> <span class="keyword">override</span></span>;</span><br><span class="line">Expression *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 两重分发</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressVisitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(DoubleExpress* de)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(AdditionExpress* ae)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressionPrinter</span> : ExpressVisitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(DoubleExpress* de)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">oss &lt;&lt; de-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(AdditionExpress* ae)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">ae-&gt;left-&gt;<span class="built_in">accept</span>(<span class="keyword">this</span>);</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">ae-&gt;right-&gt;<span class="built_in">accept</span>(<span class="keyword">this</span>);</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::ostringstream oss&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//visitor.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;visitor.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoubleExpress::accept</span><span class="params">(ExpressVisitor* visitor)</span> </span>&#123;</span><br><span class="line">visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdditionExpress::accept</span><span class="params">(ExpressVisitor* visitor)</span> </span>&#123;</span><br><span class="line">visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//visitor_test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;visitor.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> e = <span class="keyword">new</span> AdditionExpress&#123;</span><br><span class="line">    <span class="keyword">new</span> DoubleExpress&#123;<span class="number">1</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> AdditionExpress&#123;<span class="keyword">new</span> DoubleExpress&#123;<span class="number">1</span>&#125;, <span class="keyword">new</span> DoubleExpress&#123;<span class="number">1</span>&#125;&#125;&#125;;</span><br><span class="line">ExpressionPrinter ep&#123;&#125;;</span><br><span class="line">ep.<span class="built_in">visit</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>基于上述代码，如果我们要实现求值的访问者也非常简单,只需要注意修改访问权限的友元类即可：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// visitor.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressionEvaluator</span> : ExpressVisitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(DoubleExpress* de)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">res = de-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(AdditionExpress* ae)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">ae-&gt;left-&gt;<span class="built_in">accept</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">auto</span> temp = res;</span><br><span class="line">ae-&gt;right-&gt;<span class="built_in">accept</span>(<span class="keyword">this</span>);</span><br><span class="line">res += temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// visitor_test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;visitor.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> e = <span class="keyword">new</span> AdditionExpress&#123;</span><br><span class="line">    <span class="keyword">new</span> DoubleExpress&#123;<span class="number">1</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> AdditionExpress&#123;<span class="keyword">new</span> DoubleExpress&#123;<span class="number">2</span>&#125;, <span class="keyword">new</span> DoubleExpress&#123;<span class="number">3</span>&#125;&#125;&#125;;</span><br><span class="line">ExpressionPrinter ep&#123;&#125;;</span><br><span class="line">ep.<span class="built_in">visit</span>(e);</span><br><span class="line">ExpressionEvaluator ev&#123;&#125;;</span><br><span class="line">ev.<span class="built_in">visit</span>(e);</span><br><span class="line">std::cout &lt;&lt; ep.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ev.<span class="built_in">result</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="std-visit"><a href="#std-visit" class="headerlink" title="std::visit"></a>std::visit</h2><p>C++ 标准库提供了变化体(variant)来强化union,也提供了<code>std::visit</code>，来访问variant，这里简要说明std::visit怎么使用，结合cppref <a href="https://zh.cppreference.com/w/cpp/utility/variant/visit">https://zh.cppreference.com/w/cpp/utility/variant/visit</a> 中示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">struct</span> <span class="title class_">overloaded</span> : Ts... &#123;</span><br><span class="line"><span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Ts&gt; <span class="built_in">overloaded</span>(Ts...) -&gt; overloaded&lt;Ts...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VarHelper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> arg)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> arg)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::string&amp; arg)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var&#123;<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">std::<span class="built_in">visit</span>(<span class="comment">//1</span></span><br><span class="line">    [](<span class="keyword">auto</span>&amp;&amp; arg) &#123;</span><br><span class="line">    <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为 &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot; 的 int\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">double</span>&gt;)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为 &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot; 的 double\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为 &quot;</span> &lt;&lt; std::<span class="built_in">quoted</span>(arg) &lt;&lt; <span class="string">&quot; 的 std::string\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="literal">false</span>, <span class="string">&quot;观览器无法穷尽类型！&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    var);</span><br><span class="line">std::<span class="built_in">visit</span>(VarHelper&#123;&#125;, var);   <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">visit</span>(<span class="comment">//3</span></span><br><span class="line">    overloaded&#123;[](<span class="keyword">auto</span> arg) &#123; std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;,</span><br><span class="line">               [](<span class="type">double</span> arg) &#123; std::cout &lt;&lt; std::fixed &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;,</span><br><span class="line">               [](<span class="type">const</span> std::string&amp; arg) &#123; std::cout &lt;&lt; std::<span class="built_in">quoted</span>(arg) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;&#125;,</span><br><span class="line">    var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码定义了变化体var,并提供了3种visit的方法，第一种使用RTTI在运行时判断类别，是<strong>反射式方法</strong>。第二、三种都是<strong>经典方法</strong>，其中2传入了一个重载了operator()()的结构体对象，可以根据不同的arg类型进行不同的调用，3与2类似，<br>其中overloaded 结构体继承了3个lambda对象(lambda对象重载了operator()())函数，因此这里传入的overloaded对象与2中VarHelper{}相似，都是提供了int、double、string的重载operator()()的结构体而已。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>访问者模式允许我们为层次结构的每个元素添加一些功能和行为，我们已经知道了如下方法：</p><ul><li><strong>侵入式方法</strong>：为结构中每个对象添加一个虚函数，可行但违背了开闭原则。</li><li><strong>反射式方法</strong>：定义一个单独n访问者，使用<em>dynamic_cast</em>进行运行时转发。</li><li><strong>经典方法</strong>：二重分发，结构中每个元素通过accept()函数来接受访问者，通过访问者的细分(多态)，强化结构的功能。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;访问者模式&quot;&gt;&lt;a href=&quot;#访问者模式&quot; class=&quot;headerlink&quot; title=&quot;访问者模式&quot;&gt;&lt;/a&gt;访问者模式&lt;/h1&gt;&lt;p&gt;对于具有层次类型的对象类型(有继承关系)，为结构中所有类型添加方法需要大幅度的修改代码，若进行提前规划，使用访问者模</summary>
      
    
    
    
    <category term="design pattern" scheme="http://example.com/categories/design-pattern/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="访问者模式" scheme="http://example.com/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Visitor" scheme="http://example.com/tags/Visitor/"/>
    
  </entry>
  
  <entry>
    <title>浅析C++中的inline关键字</title>
    <link href="http://example.com/2023/12/13/inline/"/>
    <id>http://example.com/2023/12/13/inline/</id>
    <published>2023-12-13T11:49:21.000Z</published>
    <updated>2023-12-13T13:13:36.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>inline</strong>关键字一直被认为去声明<strong>内联函数</strong>(优先采用函数的内联替换而非进行函数调用)，然而关键词 inline 的含义是非强制的，编译器拥有对任何未标记为inline的函数使用内联替换的自由，和对任何标记为 inline 的函数生成函数调用的自由。<br>换句话说函数是否内联，与是否被inlineo标识无关，而由编译器(优化参数)决定。</p><h2 id="ODR-one-define-rule-单一定义原则"><a href="#ODR-one-define-rule-单一定义原则" class="headerlink" title="ODR(one define rule) 单一定义原则"></a>ODR(one define rule) 单一定义原则</h2><p>ORD的要求如下：</p><ul><li>任何变量、函数、类类型、枚举类型、概念或模板，在每个<strong>翻译单元</strong>中都只允许有一个定义（其中部分可以有多个声明，但只允许有一个定义）。</li><li>在整个<strong>程序</strong>中，被ODR使用的<strong>非 inline 函数或变量</strong>只允许有且仅有一个定义。</li></ul><p>简要翻译一下这两句话：</p><ul><li><strong>翻译单元指的是每个cpp文件</strong>，显然，若一个函数在某个cpp文件中定义了两次，编译期间编译器一定会报重定义错误。</li><li>若编译器编译通过，代码后续会到<strong>链接阶段</strong>，若main.cpp 调用了一个外部函数foo(int),那么链接器会到其他翻译单元中找 _Z3fooi 函数来进行e链接，若发现a.cpp、b.cpp中都定义了满足条件的foo函数，若链接器无法判断用哪一个，也会报出重定义错误。</li></ul><h2 id="定义与声明的区别"><a href="#定义与声明的区别" class="headerlink" title="定义与声明的区别"></a>定义与声明的区别</h2><p>一个声明是指（通常）将一个名称导入或重导入你的程序的C++构建。一个声明也许是一个定义，取决于导入的实体与其导入的方式，下面给出声明和定义的判断条件。</p><ul><li>Namespace和namespace aliases：namespace的声明与其aliases（别名）总是定义，尽管“定义”这个术语在此环境中不太合适，因为namespace列表的成员在之后会被“扩展”（不同于classes和enumerations）。</li><li>Classes、Class templates、函数、函数templates、成员函数与成员函数templates：当且仅当声明中包含一个与其名称相关的花括号体时，声明就是定义。该规则还适用于unions、operator、成员operator、static成员函数、构造函数与析构函数、以及此类参数版本的explicit特化。</li><li>Enumerations：当且仅当声明中包含用括号括起来的一列枚举。<br>-Local变量与nonstatic数据成员：这些实体常被当做定义处理，尽管这些差别无伤大雅。请注意在函数定义中声明函数的参数的行为本身就是定义行为，因为它指示了local变量，但在函数声明中的非定义的函数参数并不是整个函数的定义。</li><li>Global变量：若一个声明未紧接跟随在extern关键字后或有一个初始化设定式，该Global变量的声明也是其定义。其他情况则不是定义。</li><li>static数据成员：当且仅当声明出现在其所属的类、类模板的外部，或该类或类模板声明了inline或constexpr，它就是定义。</li><li>explicit与Local特化：声明后跟随一个<code>template&lt;&gt;</code>或<code>template&lt;...&gt;</code>时本身就是定义，除了static数据成员的explicit特化，static数据成员模板在其含一个initializer时也是一个定义。其他的声明不是定义。那些包含类型别名（typedef 或 using），使用声明、</li></ul><h2 id="inline-命名空间"><a href="#inline-命名空间" class="headerlink" title="inline 命名空间"></a>inline 命名空间</h2><p>内联命名空间能够把<strong>空间内函数和类型导出到父命名空间中</strong>,这样即使不指定子命名空间也可以使用其空间内的函数和类型了。<br>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Parent &#123;</span><br><span class="line">    <span class="keyword">namespace</span> Child1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Child1::foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">namespace</span> Child2</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Child2::foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parent::Child1::<span class="built_in">foo</span>();<span class="comment">//Child1::foo()</span></span><br><span class="line">    Parent::<span class="built_in">foo</span>();<span class="comment">//Child2::foo()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过inline Child2 命名空间，将Child2::foo()导出到其父命名空间中，使得我们可以使用Parent::foo() 来访问Parent::Child2::foo()中的内容，简化了代码。</p><h2 id="inline-函数、inline-变量"><a href="#inline-函数、inline-变量" class="headerlink" title="inline 函数、inline 变量"></a>inline 函数、inline 变量</h2><p>前面ODR规则说明了定义在整个程序中只能出现一次, <code>但对于inline函数或inline变量来说，在 ODR 使用了它的每个翻译单元中都需要一个定义</code>。<br>换句话说，inline的函数和变量可以`违背`规则2, 当链接器查找函数时，发现函数是inline的就不考虑它，这样就不会出现重定义的错误。</p><p>举一个例子，你实现了一个head only的日志功能，其代码可能如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LogPrintf(level, fmt, ...) \</span></span><br><span class="line"><span class="meta">LogPrintfFunc(LOG_MODULE_ID, level, std::source_location::current(), fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="comment">//！ 通过宏来打印日志</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogFatal(fmt, ...)  LogPrintf(LOG_LEVEL_FATAL, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogErr(fmt, ...)    LogPrintf(LOG_LEVEL_ERROR, fmt, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//！ 将要打印的内容封装为 LogContent ，然后dispatch，dispatch调用函数将LogContent打印出来</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogPrintfFunc</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* module_id, <span class="type">int</span> level, <span class="type">const</span> std::source_location location, <span class="type">const</span> <span class="type">char</span>* fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Args... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (level &lt; <span class="number">0</span>) &#123;</span><br><span class="line">level = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (level &gt; LOG_LEVEL_TRACE) &#123;</span><br><span class="line">level = LOG_LEVEL_TRACE;</span><br><span class="line">&#125;</span><br><span class="line">std::string module_id_print = (module_id != <span class="literal">nullptr</span>) ? module_id : <span class="string">&quot;???&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::chrono::zoned_time now&#123;std::chrono::<span class="built_in">current_zone</span>(), std::chrono::high_resolution_clock::<span class="built_in">now</span>()&#125;;</span><br><span class="line">std::string text&#123;&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fmt != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">text = std::<span class="built_in">vformat</span>(fmt, std::<span class="built_in">make_format_args</span>(args...));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="built_in">catch</span> (std::format_error&amp; e) &#123;</span><br><span class="line"><span class="built_in">LogPrintfFunc</span>(module_id, LOG_LEVEL_WARN, location, <span class="string">&quot;[format parse error]&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LogContent content = &#123;.thread_id = std::this_thread::<span class="built_in">get_id</span>(),</span><br><span class="line">                      .timestamp = std::format(<span class="string">&quot;&#123;&#125;&quot;</span>, now),</span><br><span class="line">                      .module_id = std::<span class="built_in">move</span>(module_id_print),</span><br><span class="line">                      .location = location,</span><br><span class="line">                      .level = level,</span><br><span class="line">                      .text = std::<span class="built_in">move</span>(text)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch</span>(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了控制是否打印的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//！ 开启日志</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogOutput_Enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">id = <span class="built_in">log_add_print_func</span>(log_output_filterfunc, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//！ 关闭</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogOutput_Disable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">log_remove_print_func</span>(id);</span><br><span class="line">id = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码见<a href="../asset/log.hpp">log.hpp</a></p><p>当你使用单个main文件对log进行测试时，发现其运行正常，但到涉及到多个文件依赖log时，就出现了错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;headA.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;headB.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">LogOutput_Enable</span>();</span><br><span class="line">        .....</span><br><span class="line">    <span class="built_in">LogOutput_Disable</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数依赖了A、B两个文件，A、B两个文件在其CPP中依赖了log,当链接器查找 LogOutput_Enable 时，发现A.o,B.o,main.o都提供了一个该副本，链接器无法判断要链接哪一个，只能报重定义的错误。</p><p>而解决方案有两个</p><ul><li>把那些重定义的函数声明为inline，这样A.o中的 LogOutput_Enable 对 main.o 不可见，链接器只会发现一个定义。</li><li>将log.hpp中的声明与定义分离，定义放到log.cpp中，这样只有log.o中包含LogOutput_Enable的定义</li></ul><h2 id="inline-static-成员变量"><a href="#inline-static-成员变量" class="headerlink" title="inline static 成员变量"></a>inline static 成员变量</h2><p>inline 还有一个作用就是用来初始化<strong>类中的static变量</strong><br>在C++17 之前，类静态成员变量只能采用类外定义的方式，如 class B，这样容易出现<strong>忘记定义</strong>或者被<strong>包含到多个文件重定义</strong>的问题。<br>C++17 之后，将类静态成员变量声明了inline 的形式，可以在声明时定义，更加简介也减少了错误的可能性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> std::string text;          <span class="comment">//只是声明</span></span><br><span class="line">&#125;;</span><br><span class="line">std::string B::text&#123;<span class="string">&quot;hello&quot;</span>&#125;;         <span class="comment">//这里才定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> std::string text&#123;<span class="string">&quot;hello&quot;</span>&#125;; <span class="comment">// 声明+定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X::text += <span class="string">&quot; world&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; X::text &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现代C++中 inline 早已不是内联优化的意思，其真正的含义是:“inline说明符可以应用于变量以及函数。声明为inline的变量与函数具有相同的语义:它们一方面可以在多个翻译单元中定义,另一方面又必须在每个使用它们的翻译单元中定义,并且程序的行为就像是同一个变量。”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;inline&lt;/strong&gt;关键字一直被认为去声明&lt;strong&gt;内联函数&lt;/strong&gt;(优先采用函数的内联替换而非进</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="inline" scheme="http://example.com/tags/inline/"/>
    
    <category term="ODR" scheme="http://example.com/tags/ODR/"/>
    
  </entry>
  
  <entry>
    <title>linux wayland 腾讯会议 无法共享屏幕解决方案</title>
    <link href="http://example.com/2023/12/13/wayland%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE/"/>
    <id>http://example.com/2023/12/13/wayland%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE/</id>
    <published>2023-12-13T11:06:25.000Z</published>
    <updated>2023-12-13T11:40:33.836Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>linux上腾讯会议不支持wayland 协议导致屏幕共享时无法捕获屏幕。<br>使用<code>wemeet-x11</code>启动腾讯会议，开启效果如下<br><img src="/../img/wayland%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE1.png" alt="Alt text"><br>可以看到桌面1和桌面2均显示全黑，说明无法捕获。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用obs采集屏幕创建虚拟摄像头，腾讯会议通过虚拟摄像头来共享屏幕。<br>参见：<a href="https://wiki.archlinuxcn.org/wiki/%E5%B1%8F%E5%B9%95%E6%8D%95%E8%8E%B7">https://wiki.archlinuxcn.org/wiki/屏幕捕获</a></p><ol><li>安装 <strong>obs-studio</strong>、<strong>v4l2loopback-dkms</strong>依赖包<br><code>paru -S obs-studio v4l2loopback-dkms</code></li><li>创建虚拟摄像头</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe v4l2loopback devices=1 video_nr=10 card_label=&#x27;OBS Cam&#x27; exclusive_caps=1</span><br><span class="line">sudo modprobe snd-aloop index=10 id=&#x27;OBS Mic&#x27;</span><br></pre></td></tr></table></figure><p>3.开启obs, source选择要分享的屏幕, 启动虚拟摄像头<br><img src="/../img/wayland%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE2.png" alt="Alt text"></p><p>4.开启腾讯会议，通过开启虚拟摄像头实现屏幕共享，效果如下：</p><p><img src="/../img/wayland%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE3.png" alt="Alt text"></p><p>Tip:如果出现屏幕镜像，在腾讯会议-&gt;设置-&gt;虚拟背景中关闭视频镜像。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;linux上腾讯会议不支持wayland 协议导致屏幕共享时无法捕获屏幕。&lt;br&gt;使用&lt;code&gt;wemeet-x11&lt;/code&gt;启动腾讯</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    <category term="wemeebin" scheme="http://example.com/categories/linux/wemeebin/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="wayland" scheme="http://example.com/tags/wayland/"/>
    
    <category term="wemeebin" scheme="http://example.com/tags/wemeebin/"/>
    
  </entry>
  
  <entry>
    <title>Hyprland QQ 关闭后无法打开GUI窗口解决方案</title>
    <link href="http://example.com/2023/12/13/HyprlandQQ/"/>
    <id>http://example.com/2023/12/13/HyprlandQQ/</id>
    <published>2023-12-13T10:00:55.000Z</published>
    <updated>2023-12-13T11:40:28.950Z</updated>
    
    <content type="html"><![CDATA[<p>Hyprland 关闭窗口一般绑定到快捷键(如：Win +K )，调用 exec killactive 来关闭窗口，关闭窗口不等于关闭程序，这样会导致部分程序的GUI窗口关闭后无法再次打开(该程序还在运行，如QQ等)。</p><p>可以通过 <strong>dispatch killactive</strong> 事件来对部分无法正常工作的程序来特化，killactive 修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! ~/.config/hypr/scripts/killactive.sh</span></span><br><span class="line">file_path=<span class="string">&quot;<span class="variable">$HOME</span>/.config/QQ/qq_window_id&quot;</span></span><br><span class="line"><span class="built_in">echo</span> $(hyprctl activewindow -j | jq -r <span class="string">&quot;.class&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(hyprctl activewindow -j | jq -r <span class="string">&quot;.class&quot;</span>)</span>&quot;</span> = <span class="string">&quot;QQ&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    wid=`xdotool getactivewindow`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$wid</span> &gt; <span class="variable">$file_path</span> </span><br><span class="line">    xdotool windowunmap <span class="variable">$wid</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    hyprctl dispatch killactive <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这段代码作用是：若关闭的窗口为QQ,记录窗口 id ，使用 <code>xdotool windowunmap</code> 来<code>unmap</code>窗口，不关闭窗口。</p><p>恢复QQ窗口对应为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! ~/.config/hypr/scripts/resumeQQ.sh</span></span><br><span class="line">file_path=<span class="string">&quot;<span class="variable">$HOME</span>/.config/QQ/qq_window_id&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$file_path</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    w_id=$(<span class="built_in">cat</span> <span class="string">&quot;<span class="variable">$file_path</span>&quot;</span>)</span><br><span class="line">    xdotool windowmap <span class="variable">$w_id</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    bash linuxqq   </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>检查<strong>window_id</strong> 是否存在，存在就<code>xdotool windowmap</code> 窗口，不存在就启动QQ程序</p><p>以上解决方法需要在启动Hyprland时删除 <strong>qq_window_id</strong> 文件，向<strong>hyprland.conf</strong> 中添加该行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec-once = rm -f ~/.config/QQ/qq_window_id</span><br></pre></td></tr></table></figure><p>配置设置快捷键如下(根据个人喜好配置)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$mainMod = SUPER</span><br><span class="line">bind = $mainMod, Z, exec, bash ~/.config/hypr/scripts/resumeQQ.sh               # QQ</span><br><span class="line">bind = $mainMod+SHIFT, Z, exec, killall -SIGUSR1 /opt/QQ/qq                     # close QQ</span><br><span class="line">bind = $mainMod, K, exec, bash ~/.config/hypr/scripts/killactive.sh             # kill windows</span><br></pre></td></tr></table></figure><p>即可实现<code>Win +K</code> 关闭窗口，<code>Win + Z</code> 打开QQ，<code>Win + Shift +Z</code> 退出QQ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hyprland 关闭窗口一般绑定到快捷键(如：Win +K )，调用 exec killactive 来关闭窗口，关闭窗口不等于关闭程序，这样会导致部分程序的GUI窗口关闭后无法再次打开(该程序还在运行，如QQ等)。&lt;/p&gt;
&lt;p&gt;可以通过 &lt;strong&gt;dispatc</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    <category term="linuxqq" scheme="http://example.com/categories/linux/linuxqq/"/>
    
    
    <category term="hyprland" scheme="http://example.com/tags/hyprland/"/>
    
    <category term="linuxqq" scheme="http://example.com/tags/linuxqq/"/>
    
  </entry>
  
  <entry>
    <title>linux Kokomi(珊瑚宫心海)光标主题</title>
    <link href="http://example.com/2023/12/13/Kokomi%E5%85%89%E6%A0%87%E4%B8%BB%E9%A2%98/"/>
    <id>http://example.com/2023/12/13/Kokomi%E5%85%89%E6%A0%87%E4%B8%BB%E9%A2%98/</id>
    <published>2023-12-13T09:37:38.000Z</published>
    <updated>2023-12-13T11:40:23.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cursor-therme-Kokomi"><a href="#cursor-therme-Kokomi" class="headerlink" title="cursor_therme (Kokomi)"></a>cursor_therme (Kokomi)</h1><p>珊瑚宫心海主题，适用于linux系统<br>cursors_32、cursors_48、cursor_128分别对应<code>32*32</code>、<code>48*48</code>和<code>128*128</code>大小的鼠标指针</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li><code>git clone https://github.com/lzl200110/Kokomi-cursor.git</code></li><li>将Kokomi文件放到 &#x2F;usr&#x2F;share&#x2F;icons&#x2F;</li><li>选择合适大小文件命名为cursors</li><li>设置光标主题为kokomi<br>  参见 <a href="https://wiki.archlinuxcn.org/wiki/%E5%85%89%E6%A0%87%E4%B8%BB%E9%A2%98">https://wiki.archlinuxcn.org/wiki/光标主题</a></li></ul><h2 id="指针预览"><a href="#指针预览" class="headerlink" title="指针预览"></a>指针预览</h2><p><img src="/../img/image_kokomi.png" alt="Alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cursor-therme-Kokomi&quot;&gt;&lt;a href=&quot;#cursor-therme-Kokomi&quot; class=&quot;headerlink&quot; title=&quot;cursor_therme (Kokomi)&quot;&gt;&lt;/a&gt;cursor_therme (Kokomi)&lt;/</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    <category term="光标主题" scheme="http://example.com/categories/linux/%E5%85%89%E6%A0%87%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="光标主题" scheme="http://example.com/tags/%E5%85%89%E6%A0%87%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
</feed>
